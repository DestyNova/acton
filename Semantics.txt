########################################### Abstract syntax ############################################

Variables:          x,y
Statevars:          z
Type constants:     c,d

Locations:          l
Actor refs:         a,b
Message tags:       m

Integers:           i
Floats:             f
Strings:            s

Expressions:        E       ::=     x  |  z  |  V  |  (A)  |  (M)  |  lambda F,K: E  |
                                    E(A,M)  |  E.x  |  E if E else E  |  E is E  |
                                    await E  |  isinstance(E,c)  |  do S

Actuals:            A       ::=     E,A    |  *E   |  .
Mappings:           M       ::=     x=E,M  |  **E  |  .

Formals:            F       ::=     x,F  |  x=E,F  |  *x   |  .
Keywords:           K       ::=     x,K  |  x=E,K  |  **x  |  .

Values:             V,W     ::=     True  |  False  |  None  |  (O)  |  (B)  |  c  |
                                    ---- Only intangible constructs below
                                    CLOS(B;F,K):S  |  l  |  a  |  a.m  |
                                    ACTOR V  |  ASYNC(a) V  |  SYNC(a) V  |  
                                    CLASS(c):B  |  (c):B

Orderings:          O       ::=     O,V    |  .                                     associative
Bindings:           B       ::=     B,x=V  |  B,c=V  |  .                           associative & commutative\duplicates, disjoint c

Statements:         S       ::=     E  |  P = E  |  D  |  return E  |  pass  |
                                    E.x = E  |  if E: S else S  |  while E: S  |
                                    var z = E  |  z = E  |
                                    raise E  |  try S Z else S finally S  |
                                    S; S                                            associative, with unit 'pass'

Declarations:       D       ::=     def x(F,K): S  |
                                    async def x(F,K): S  |  
                                    sync def x(F,K): S  |
                                    actor x(F,K): S  |  
                                    class c(d): M  |
                                    D; D                                            associative & commutative & disjoint

Patterns:           P       ::=     x  |  (F)  |  (K)
Excepts:            Z       ::=     except c as y: S Z  |  .

---- Only intangible constructs below

Global states:      G       ::=     a:<L|Q>  |  G,G                                 associative, commutative & disjoint
Local states:       L       ::=     z=V, L  |  l=V, L  |  .                         associative, commutative & disjoint
Queues:             Q       ::=     m=E,Q  |  .                                     associative & disjoint
Histories:          H       ::=     m=V,H  |  m=do raise V, H  |  .                 associative & disjoint

E-in-E contexts:    EE      ::=     _.x  |  _(A,M)  |  E if _ else E  |  
                                    V(O,_,A,M)  |  V(O,*_,M)  |  V(O,B,x=_,M)  |  V(O,B,**_)  |
                                    (O,_,A)  |  (O,*_)  |  (B,x=_,M)  |  (B,**_)  |
                                    _ is E  |  V is _  |  await _  |  isinstance(_,c)

E-in-S contexts:    SE      ::=     _  |  return _  |  P = _  |  if _: S else S  |
                                    _.x = E  |  var z = _  |  z = _  |  raise _
                                    
S-in-S contexts:    SS      ::=     _; S  |  try _ Z else S finally S

E-in-Q contexts:    QE      ::=     H, m=_, Q


####################################### Expression evaluation ##########################################

***** B |- c(d) ********************

B  |-  c(c)

B,c=CLASS(c'):B'   |-  c(d)                                                     if  B |- c'(d)


***** B |- L | E --> L' | E' *******

B  |-  L  |  EE[E]          -->     L'  |  EE[E']                               if  B |- L | E --> L' | E'

B  |-  L  |  do S           -->     L'  |  do S'                                if  B |- L | S --> L' | S'

B  |-  L  |  E              -->     L  |  E'                                    if  B |- E --> E'

B  |-  L,z=V  |  z          -->     L,z=V  |  V

B  |-  L,l=(c):B'  |  l.x   -->     L,l=(c):B'  |  V                            if  (B').x --> V
B  |-  L,l=(c):B'  |  l.x   -->     L,l=(c):B'  |  CLOS(B2,y=l;F,K):S           if  x # B' and B |- c.x ==> @instmethod CLOS(B2;y,F,K):S
B  |-  L,l=(c):B'  |  l.x   -->     L,l=(c):B'  |  V                            if  x # B' and B |- c.x ==> V otherwise

B  |-  L  |  c(O,B')        -->     L,l=(c):.  |  do l._init_(O,B'); return l   if  B = B1,c=CLASS(d):B2  and  N |- c(object)

B  |-  L,l=(c):B'  |  isinstance(l,d)    
                            -->     L,l=(c):B'  |  True                         if  B |- c(d)
                            -->     L,l=(c):B'  |  False                        if  not B |- c(d)


***** B |- E --> E' ****************

B  |-  E                    -->     E'                                          if  E --> E'

B,x=V  |-  x                -->     V

B  |-  lambda F,K: E        -->     CLOS(B;F,K): return E

B  |-  ((c):B').x           -->     V                                           if  (B').x --> V
B  |-  ((c):B').x           -->     CLOS(B2,y=((c):B');F,K):S                   if  x # B' and B |- c.x ==> @instmethod CLOS(B2;y,F,K):S
B  |-  ((c):B').x           -->     V                                           if  x # B' and B |- c.x ==> V otherwise

B  |-  c.x                  -->     CLOS(B',y=c;F,K):S                          if  B |- c.x ==> @classmethod CLOS(B';y,F,K):S
B  |-  c.x                  -->     W                                           if  B |- c.x ==> W otherwise

B  |-  c(.,B')              -->     (c):B'                                      if  B = B1,c=CLASS(d):B2  and  N |- c(struct)

B  |-  isinstance((c):B',d) -->     True                                        if  B |- c(d)
                            -->     False                                       if  not B |- c(d)


***** B |- E ==> E' ****************

B,c=CLASS(d):B'  |-  c.x    ==>     V                                           if  (B').x --> V
B,c=CLASS(d):B'  |-  c.x    ==>     V                                           if  x # B' and B |- d.x ==> V


***** E --> E' *********************

E1 if True else E2          -->     E1
E1 if False else E2         -->     E2

do B; pass                  -->     None
do B; return V              -->     V                                           if  fc(V) # dc(B)
do B; raise V               -->     do raise V                                  if  fc(V) # dc(B)

EE[do raise V]              -->     do raise V

(O,*(O'))                   -->     (O,O')
(B,**(B'))                  -->     (B',B)                                      Note the order!

V(O,B)                      -->     do B'; (F)=(O); (K)=(B); S                  if  V = CLOS(B';F,K):S

(B).x                       -->     V                                           if  B |- x --> V

l is l                      -->     True
l is l'                     -->     False                                       if  l != l'

a is a                      -->     True
a is b                      -->     False                                       if  a != b


######################################## Statement execution ###########################################


***** B |- L | S --> L' | S' *******

B  |-  L  |  SS[S]          -->     L'  |  SS[S']                               if  B |- L | S --> L' | S'

B  |-  L  |  SE[E]          -->     L'  |  SE[E']                               if  B |- L | E --> L' | E'

B  |-  L  |  S              -->     L'  |  S'                                   if  L | S --> L' | S'

B  |-  L  |  S              -->     L  |  S'                                    if  B |- S --> S'


***** B |- S --> S' ****************

B  |-  B'; S                -->     B'; S'                                      if  B,B' |- S --> S'

B  |-  S                    -->     S'                                          if  S --> S'

B  |-  D                    -->     B'                                          if  B,B' |- D ==> B'


***** B |- D ==> B *****************

B  |-  def x(F,K): S        ==>     x = CLOS(B;F,K): S
B  |-  async def x(F,K): S  ==>     x = ASYNC(a) (CLOS(B;F,K):S)                if  (B)._self_ --> a
B  |-  sync def x(F,K): S   ==>     x = SYNC(a) (CLOS(B;F,K):S)                 if  (B)._self_ --> a
B  |-  actor x(F,K): S      ==>     x = ACTOR (CLOS(B;_self_,F,K):S)
B  |-  class c(d): M        ==>     c = CLASS(d): B'                            if  B |- M ==> B'
B  |-  D1; D2               ==>     B1; B2                                      if  B |- D1 ==> B1 and B |- D2 ==> B2


***** B |- M ==> B *****************

B  |-  x=y,M                ==>     x=V,B'                                      if  B |- x --> V and B |- M ==> B'
B  |-  .                    ==>     .


***** S --> S' *********************

V; S                        -->     S
return V; S                 -->     return V
raise V; S                  -->     raise V

if True: S1 else S2         -->     S1
if False: S1 else S2        -->     S2
while E: S                  -->     if E: S; while E: S else pass

(x,F) = (V,O)               -->     x = V; (F) = (O)
(x=E,F) = (None,O)          -->     x = E; (F) = (O)
(x=E,F) = (V,O)             -->     x = V; (F) = (O)
(*x) = (O)                  -->     x = (O)
() = ()                     -->     pass

(x,K) = (x=V,B)             -->     x = V; (K) = (B)
(x=E,K) = (x=None,B)        -->     x = E; (K) = (B)
(x=E,K) = (x=V,B)           -->     x = V; (K) = (B)
(**x) = (B)                 -->     x = (B)
() = ()                     -->     pass

SE[do raise V]              -->     raise V

try B; S Z else S1 finally S2                       -->   B; try S Z else S1 finally S2
try return V Z else S1 finally S2                   -->   S2; return V
try pass Z else pass finally S2                     -->   S2
try pass Z else S1 finally S2                       -->   try S1 . else pass finally S2
try raise V except c as y: S Z else S1 finally S2   -->   try raise V Z else S1 finally S2          if  V = (d):B and c != d
try raise V except c as y: S Z else S1 finally S2   -->   try y=V; S . else pass finally S2         if  V = (c):B
try raise V . else S1 finally S2                    -->   S2; raise V


***** L | S --> L' | S' ************

L  |  B; S                  -->     L'  |  B; S'                                    if  L | S --> L' | S'

L  |  var z=V               -->     L,z=V  |  pass
L,z=V  |  z = W             -->     L,z=W  |  pass

L,l=(c):B  |  l.x = V       -->     L,l=(c):B,x=V  |  pass                          if  x # B
L,l=(c):B,x=W  |  l.x = V   -->     L,l=(c):B,x=V  |  pass



######################################### Global reduction #############################################


***** B |- G --> G' ****************

B  |-  G1, G2               -->     G1', G2                                         if  B |- G1 --> G1'

B  |-  a:<L | QE[E]>        -->     a:<L' | QE[E']>                                 if  B |- L | E --> L' | E'

B  |-  G                    -->     G'                                              if  G --> G'


***** G --> G' *********************

a:<L | QE[ (SYNC(a) V)(O,B) ]>                          -->     a:<L | QE[ V(O,B) ]>
a:<L | QE[ (ASYNC(a) V)(O,B) ]>                         -->     a:<L | QE[ a.m ],m=V(O,B)>
a:<L | QE[ (ACTOR V)(O,B) ]>                            -->     a:<L | QE[ await b.m ]>,     b:< . | m=V(b,O,B)>
a:<L | QE[ (SYNC(b) V)(O,B) ]>,     b:<L' | Q>          -->     a:<L | QE[ await b.m ]>,     b:<L' | Q,m=V(O,B)>
a:<L | QE[ (ASYNC(b) V)(O,B) ]>,    b:<L' | Q>          -->     a:<L | QE[ b.m ]>,           b:<L' | Q,m=V(O,B)>
a:<L | QE[ await b.m ]>,            b:<L' | H,m=V,Q>    -->     a:<L | QE[ V ]>,             b:<L' | H,m=V,Q>

a:<L | QE[ await b.m ]>,   b:<L' | H,m=do raise V,Q>    -->     a:<L | QE[ do raise V ]>,    b:<L' | H,m=do raise V,Q>




Recent decisions:
- Mutable lists, dicts and sets are true class instances (although built-in)
- Frozen lists, dicts and sets are true immutable class instances (although built-in)
- Automatic coercion of mutable objects into immutable ones is abandoned for now (replaced by explicit conversion calls)
- The 'protocol' and 'extension' declarations introduce static overloading, which gets translated into class declaration and explicit witness terms
- Attribute selection can thus be overloaded, and supported on any type
- Indexed selection and indexed update get translated to overloaded _getitem_ and _setitem_ calls, respectively
- Built-in names int, float, str and bool are constructor/conversion functions, supporting multiple argument types via overloading
- Class inheritance is single ancestor only (all other types of mix-ins are expressed as protocol adoption)
- Classes are the only nominal types, and only these support the 'isinstance' primitive
- Narrowing of the option type is done through ==None and !=None comparisons
- Narrowing of the primitive union type is done through built-ins 'isint', 'isfloat', 'isbool' and 'isstr'
- Subtyping, as defined by class inheritance + structural rules, is ubiquitous
- Class terms are subtypes of the function type (to allow for instantiation)
- Type parameters to named types are written within brackets, as in List[int], dict[str,A]
- Brackets also introduce type parameters in class declarations, as in class Bepa[T] (Apa[T]): ... 
- And brackets introduce type parameters in explicitly polymorphic function/method declarations, as in def swap[A,B]((A,B)) -> (B,A): ...
- Class names are also type names
- Base class expressions are *type* expressions
- Local classes are supported but all references to their names must be absent from the return type or env when their scope ends


=========================================================================================================

Normalization:

- All imported or built-in names are qualified by module
X All parameters are positional
X Parameter defaults are moved inside function definitions
- Protocols and extensions are translated into classes
- Overloaded names are explicitly qualified by class
- Comprehensions are translated into loops
X String literals are concatenated
- Tuple (and list) patterns are replaced by a var pattern followed by explicit element assignments
- For loops are replaced by while over iterators
- With statemenmts are replaced by enter/exit calls + exception handling

Deactorization:

- Actor state is made explicit in terms of parameter __self__
- Communication and exception handling is made explicit by means of RTS calls (ACTOR, ASYNC, AWAIT, PUSH, POP)
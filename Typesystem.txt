TODO:
    - Distinguishing required and available (defaulted) struct/class/protocol attributes
    - Witness translation
    - Automatic lifting of 's' to str (subtyping?)
    - Automatic lifting of int,... etc to (int|u) (subtyping?)
    - Static deadlock detection
    - Protocols as types, with existential quantification
    - Struct cases (and pattern-matching)
    - Type parameter variances
    - Higher-order polymorphism
    - Type macros / abstract types / associated types
    - Kind correctness
    - Read state effect (distinguish state effects per data structure?)
    - Merge struct and protocol? Merge struct and records?
    - Clean up row order (l-to-r or r-to-l)
    - Read MPJ's Parametric Type Classes


NOTES:
    - Struct instances are represented as expanded records (including all supertype fields), just like struct & class decls
    - That way abstract attributes can be concretized in subtypes as well as in instances, and found at the same record offset
    - Static methods in protocols must mention Self, or else they would be ambiguous (see translation into structs)
    - The [q] part in struct, class, protocol and extension is required, but can be left out (and inferred) in actor and def(s).
    - Unambiguity in type schemes: for each [q]=>t it must hold that ftv(q) <= ftv(t)  (not checked here)
    - Structs, classes and protocols have no ambiguity problems since q is always explicit there and the dom(q) are all in the resulting type.
    - Consistency requirement on extensions not checked here (from Haskell): if  N |- t impl u  and  N |- u < u'  then  N |- t impl u'
        - Alternatively: if  N |- t ~ extension(u)  and  N |- u < u'  then  N |- t ~ extension(u')
        - Concretely: if   c:[q]=>extension(d[o])  and  d[q']=>protocol(d'[o'])  both exist in N
                      then c:[q"]=>extension(d'[o"])  must also exist in N such that  [o/dom(q')]o' = phi(o") and  N,q,[o/dom(qd)]q' |- q"
    - Acyclic subtype/protocol hierarchy not checked here
    - Single subtype ancestry not checked here
    - Protocol attributes must be globally unique (not checked here)
    - Precondition to rule ImplExt: a unique (or best matching...) t(u) extension must exist in N (not checked here)
    - Termination requirements on q in extension c[q](o) not checked here (allow growing terms except in protocol cycles)
    - Self in the range of a substitution is forbidden but not checked here (maybe allow in covariant positions in the future)
    - The notation c[q] as a *type* is a bit sloppy and should be improved
    
    - Unused meta variables: g,h,k,v,w,J,R,U,Y


***** Syntax *******************************************************************************************************************************************************

                    
Type constants:     c,d                                                                                 including int,bool,str,literals,Msg,Ref

Type variables:     X                                                                                   includes Self

Types:              t       ::=     X  |  u  |  e(p,r)->t  |  (p)  |  (r)  |  ?t  |  None  |  @u        var, con, fun, tuple, record, opt, void, class type

Constructor types:  u       ::=     c[o]

Ordered types:      o       ::=     t,o  |  .                                                           associative

Position rows:      p       ::=     t,p  |  *X  |  .                                                    associative

Type environments:  n       ::=     x:T,n  |  .                                                         associative, commutative, disjoint

Type rows:          r       ::=     x:T,r  |  **X  |  .                                                 associative, commutative\duplicates

Effect rows:        e       ::=     ret(t),e  |  sync,e  |  async,e  |  act,e  |  !,e  |  X  |  .       associative, commutative\duplicates

Qua(l|nt)ifiers:    q       ::=     X(o)  |  q,q  |  .                                                  associative

Schemas:            T       ::=     [q] => t  |  t

Constraints:        C       ::=     t(o)  |  C,C  |  .                                                  associative, commutative

Type info:          I       ::=     class(o):n  |  struct(o):n  |  protocol(o):n  |  extension(o)

eNvironments:       N       ::=     x:T  |  z:t  |  x:#  |  z:#  |  c:[q]=>I  |  X(o)  |  N,N  |  .     associative, commutative\duplicates


***** Judgments ****************************************************************************************************************************************************


N |- D : N'                 Definition D generates bindings N' in environment N

N |- t ~ I                  Type t is defined as I in environment N

N |- t impl u               Type t implements protocol u in environment N

N |- t < u                  Type t is a subtype of u in environment N

N |- C                      Constraint C holds in environment N

N |- E : T | e              Expression E has type (scheme) T in environment N and effect context e

N |- F : p | N' | e         Formal parameter F has type p in environment N (if updated with N') and effect context e

N |- K : r | N' | e         Keyword parameter K has type r in environment N (if updated with N')and effect context e

N |- x : t | N'             Variable x has type t in environment N (if updated with N')

N |- S ~ N' | e             Statement S generates bindings N' in environment N and effect context e

N |- S : t | e              Statement S returns values of type t in environment N and effect context e


***** N |- D : N' **************************************************************************************************************************************************


N' = N,q,Self(c[q])     N' |- u ~ struct(o):n'      N' |- ui ~ protocol(oi):ni     N' |- M : n2 | e      n2 in n',U(ni),n
------------------------------------------------------------------------------------------------------------------------- (DefStruct)
N |- struct c[q](u,ui):n,M  :  c:[q]=>struct(u,ui):(n',U(ni),n)

N' = N,q,Self(c[q])     N' |- u ~ class(o):n'      N' |- ui ~ protocol(oi):ni     N' |- M : n2 | e      n2 in n',U(ni),n
------------------------------------------------------------------------------------------------------------------------ (DefClass)
N |- class c[q](u,ui):n,M  :  c:[q]=>class(u,ui):(n',U(ni),n)

N' = N,q,Self(c[q])     N' |- ui ~ protocol(oi):ni      N' |- M : n2 | e      n2 in U(ni),n
------------------------------------------------------------------------------------------- (DefProto)
N |- protocol c[q](ui):n,M  :  c:[q]=>protocol(ui):(U(ni),n)


N' = N,q,Self(c[q])     N' |- c[q] ~ protocol(o):n     N' |- ui ~ protocol(oi):ni      N' |- M : n2 | e     n2 in U(ni)
----------------------------------------------------------------------------------------------------------------------- (DefExtP)
N |- extension c[q](ui):M  :  c:[q]=>extension(ui)

N' = N,q,Self(c[q])     N' |- c[q] ~ struct(o):n     N' |- ui ~ protocol(oi):ni      N' |- M : n2 | e     n2 in U(ni)
--------------------------------------------------------------------------------------------------------------------- (DefExtS)
N |- extension c[q](ui):M  :  c:[q]=>extension(ui)

N' = N,q,Self(c[q])     N' |- c[q] ~ class(o):n     N' |- ui ~ protocol(oi):ni      N' |- M : n2 | e     n2 in U(ni)
-------------------------------------------------------------------------------------------------------------------- (DefExtC)
N |- extension c[q](ui):M  :  c:[q]=>extension(ui)


N' = N,q,bv(F,P,S):#,bzv(N,S):#,_self_:Ref    N' |- F : p ~ N1 | e    N',N1 |- K : r ~ N2 | e    N',N1,N2 |- S : t | e
---------------------------------------------------------------------------------------------------------------------- (DefAct)
N |- actor x[q](F,K):S  :  x: [q] => e,act(p,r)->t

N' = N,q,bv(F,P,S):#    N' |- F : p ~ N1 | e     N',N1 |- K : r ~ N2 | e     N',N1,N2 |- S : t | e
-------------------------------------------------------------------------------------------------- (DefSync)
N |- sync x[q](F,K):S  :  x: [q] => e,sync(p,r)->t

N' = N,q,bv(F,P,S):#    N' |- F : p ~ N1 | e     N',N1 |- K : r ~ N2 | e     N',N1,N2 |- S : t | e
-------------------------------------------------------------------------------------------------- (DefAsync)
N |- async x[q](F,K):S  :  x: [q] => e,async(p,r)->Msg[t]

N' = N,q,bv(F,P,S):#    N' |- F : p ~ N1 | e     N',N1 |- K : r ~ N2 | e     N',N1,N2 |- S : t | e
-------------------------------------------------------------------------------------------------- (DefFun)
N |- def x[q](F,K):S  :  x : [q] => e(p,r)->t


N |- D1 : N1      N |- D2 : N2
------------------------------ (Defs)
N |- D1,D2 : N1,N2


***** N |- t ~ I ***************************************************************************************************************************************************


phi = [o/dom(q)]     N,c:[q]=>I |- phi(q)
----------------------------------------- (Info)
N,c:[q]=>I |- c[ti] ~ phi(I)


***** N |- t impl u ************************************************************************************************************************************************


N |- t ~ extension(u,o)      N |- u ~ protocol(o'):n                                N,X(u,o) |- u ~ protocol(o):n
---------------------------------------------------- (ImplExt)                      ----------------------------- (ImplVar)
N |- t impl u                                                                       N,X(u,o) |- X impl u


N |- t impl u       N |- u < u'
------------------------------- (ImplSub)
N |- t impl u'


***** N |- t < t' **************************************************************************************************************************************************


N |- u ~ protocol(u',o):n     N |- u' ~ protocol(o'):n'
------------------------------------------------------- (SubProto)
N |- u < u'

N |- u ~ struct(u',o):n     N |- u' ~ struct(o'):n'                                 N |- u ~ class(u',o):n      N |- u' ~ class(o'):n'
--------------------------------------------------- (SubStruct)                     -------------------------------------------------- (SubClass)
N |- u < u'                                                                         N |- u < u'

N,X(u,o) |- u ~ struct(o'):n                                                        N,X(u,o) |- u ~ class(o'):n
---------------------------- (SubVarS)                                              --------------------------- (SubVarC)
N,X(u,o) |- X < u                                                                   N,X(u,o) |- X < u


N |- p' < p     N |- r' < r     N |- t < t'                                         x:t,r "canonically ordered"
------------------------------------------- (SubFun)                                -------------------------------- (SubArgs)
N |- e(p,r)->t < e(p',r')->t'                                                       N |- e(p,x:t,r)->t < e(p,t,r)->t


N |- p < p'                                                                         N |- t < t'     N |- p < p'
--------------- (SubTup)                                                            --------------------------- (SubPos)
N |- (p) < (p')                                                                     N |- t,p < t',p'

N |- r < r'                                                                         N |- . < r
--------------- (SubRec)                                                            --------------- (SubLacks)
N |- (r) < (r')                                                                     N |- . < x:?t,r

N |- r < r'                                                                         N |- t < t'     N |- r < r'
------------------- (SubRow1)                                                       --------------------------- (SubRow2)
N |- x=T,r < x=T,r'                                                                 N |- x=t,r < x=t',r'


N |- u ~ struct(u',o):n      N |- u' ~ struct(o'):n'                                N |- u ~ class(u',o):n      N |- u' ~ class(o'):n'
---------------------------------------------------- (SubAt1)                       -------------------------------------------------- (SubAt2)
N |- @u < @u'                                                                       N |- @u < @u'


----------- (SubOpt)                                                                -------------- (SubNone)
N |- t < ?t                                                                         N |- None < ?t


N |- t1 < t2      N |- t2 < t3
------------------------------ (SubTrans)                                           ---------- (SubRefl)
N |- t1 < t3                                                                        N |- t < t


***** N |- C *******************************************************************************************************************************************************


                                            N |- C1      N |- C2                    N |- t < u      N |- t(o)               N |- t impl u     N |- t(o)
------ (Con0)       --------- (Con1)        -------------------- (Con2)             ------------------------- (ConSub)      --------------------------- (ConImpl)
N |- .              N |- t(.)               N |- C1,C2                              N |- t(u,o)                             N |- t(u,o)


***** N |- E : T | e ***********************************************************************************************************************************************


N |- E : t | e     N |- t < u
----------------------------- (Sub)
N |- E : u | e


N,q |- E : t | e      btv(q) not in ftv(N)                                          N |- E : [q] => t     phi = [o/dom(q)]     N |- phi(q)
------------------------------------------ (Gen)                                    ------------------------------------------------------ (Inst)
N |- E : [q] => t | e                                                               N |- E : phi(t)


------------------ (Var1)                                                           -------------------- (Read)
N,x:T |- x : T | e                                                                  N,z:t |- z : t | e,!

N |- u' ~ protocol(o):(x:T,n)     N |- w : u impl u'     x staticm                  Self is guaranteed to appear in T, so the expected type of x
------------------------------------------------------------------ (Var2)           uniquely determines u. Also, u' is determined by x (and T).
N |- x : [u/Self]T  ~>  w.x                                                         By uniqueness of instances, u' then determines witness w.


N |- u' ~ protocol(o):(x:T,n)     N |- w : u impl u'     N |- E : u      x not staticm
-------------------------------------------------------------------------------------- (SelP)
N |- E.x : [u/Self]T  ~>  w.x(E)

N |- E : u | e     N |- u ~ struct(o):(x:T,n)    x not staticm                      N |- E : u | e     N |- u ~ class(o):(x:T,n)    x not staticm
-------------------------------------------------------------- (SelS1)              ------------------------------------------------------------- (SelC1)
N |- E.x : [u/Self]T | e                                                            N |- E.x : [u/Self]T | e

N |- E : @u     N |- u ~ struct(o):(x:e(p,r)->t,n)     x instm                      N |- E : @u     N |- u ~ class(o):(x:e(p,r)->t,n)     x instm
-------------------------------------------------------------- (SelS2)              -------------------------------------------------------------- (SelC2)
N |- E.x : [u/Self]e(Self,p,r)->t | e'                                              N |- E.x : [u/Self]e(Self,p,r)->t | e'

N |- E : @u     N |- u ~ struct(o):(x:T,n)     x not instm                          N |- E : @u     N |- u ~ class(o):(x:T,n)     x not instm
---------------------------------------------------------- (SelS3)                  --------------------------------------------------------- (SelC3)
N |- E.x : [u/Self]T | e                                                            N |- E.x : [u/Self]T | e

N |- E : (x:T,r) | e
-------------------- (Sel)
N |- E.x : T | e


N |- c[o] ~ struct(o'):n                                                            N |- c[o] ~ struct(o'):n
------------------------ (AtClass)                                                  ------------------------ (AtStruct)
N |- c : @c[o]                                                                      N |- c : @c[o]

                                        
N |- F : p ~ N1 | e'     N,N1 |- K : r ~ N2 | e'     N,N1,N2 |- E : t | e'
-------------------------------------------------------------------------- (Lam)
N |- (lambda F,K: E) : e'(p,r)->t | e


N |- E : e(p,r)->t | e     N |-> (A) : (p) | e     N |- (M) : (r) | e
--------------------------------------------------------------------- (App)
N |- E(A,M) : t | e

N |- c[o] ~ struct(o'):n      N |- (M) : (n) | e
------------------------------------------------ (ConS)
N |- c(.,M) : c[o] | e

N |- c[o] ~ class(o'):(_init_(p,r):n)      N |- (A) : p | e     N |- (M) : (r) | e
---------------------------------------------------------------------------------- (ConC)
N |- c(A,M) : c[o] | e


N |- E : bool | e     N |- E1 : t | e     N |- E2 : t | e
--------------------------------------------------------- (If1)
N |- E1 if E else E2 : t | e


N |- E : t | e     N |- (A) : (p) | e                                               N |- E : (p) | e
------------------------------------- (Tup)                                         ------------------- (Star1)
N |- (E,A) : (p,t) | e                                                              N |- (*E) : (r) | e

C,C' | N |- E : t | e     N |- (M) : (r) | e                                        N |- E : (r) | e
-------------------------------------------- (Rec)                                  -------------------- (Star2)            ------------------ (Null)
N |- (x=E,M) : (r,x:gen(N,C,t,C')) | e                                              N |- (**E) : (r) | e                    N |- (.) : (.) | e


N |- E : Msg(t) | e                                                                 N |- S : t | e
------------------------- (Await)                                                   ----------------- (Do)
N |- await E : t | e,sync                                                           N |- do S : t | e


-------------------- (None)
N |- None : None | e


***** N |- F : p | N | e *******************************************************************************************************************************************


N |- x : t | N1     N,N1 |- F : p | N2 | e                                          N |- x : (p) | N1
------------------------------------------ (TupVar)                                 -------------------- (TupStar)
N |- x,F : p,t ~ N1,N2 | e                                                          N |- *x : p | N1 | e

N |- x : t | N1     N |- E : t | e     N,N1 |- F : p | N2 | e
------------------------------------------------------------- (TupOpt)              ------------------ (TupNull)
N |- x=E,F : p,t | N1,N2 | e                                                        N |- . : . | . | e


***** N |- K : r | N | e *******************************************************************************************************************************************


N |- x : T | N1     N,N1 |- F : r | N2 | e                                          N |- x : (r) | N1
------------------------------------------ (RecVar)                                 --------------------- (RecStar)
N |- x,K : r,x:T | N1,N2 | e                                                        N |- **x : r | N1 | e

N |- x : T | N1     N |- E : T | e     N,N1 |- F : r | N2 | e
------------------------------------------------------------- (RecOpt)              ------------------ (RecNull)
N |- x=E,K : r,x:T | N1,N2 | e                                                      N |- . : . | . | e


***** N |- x : t | N ***********************************************************************************************************************************************


-------------------- (Bind)                                                         ------------------ (Rebind)
N,x:# |- x : T | x:T                                                                N,x:t |- x : t | .


***** N |- P : t | N | e *******************************************************************************************************************************************


N |- x : t | N1                         N |- F : p | N1 | e                         N |- K : r | N1 | e
------------------- (PatVar)            ----------------------- (PatTup)            ----------------------- (PatRec)
N |- x : t | N1 | e                     N |- (F) : (p) | N1 | e                     N |- (K) : (r) | N1 | e


***** N |- S ~ N | e ***********************************************************************************************************************************************


N |- E : t | e              N |- P : t ~ N' | e     N |- E : t | e                  N,N' |- D : N'
-------------- (Run)        -------------------------------------- (Assign)         --------------- (Def)
N |- E ~ . | e              N |- P = E ~ N' | e                                     N |- D ~ N' | e


N |- E : t | e
---------------------------- (Return)                                               ----------------- (Pass)
N |- return E ~ . | e,ret(t)                                                        N |- pass ~ . | e


N |- E1 : u | e,!     N |- u ~ class(o):x:t,n     N |- E2 : t | e,!
------------------------------------------------------------------- (Mut)
N | E1.x = E2 ~ . | e,!


N |- E : bool | e     N |- S1 ~ N1 | e     N |- S2 ~ N2 | e                         N |- E : bool | e     N |- S ~ N' | e
----------------------------------------------------------- (If2)                   ------------------------------------- (While)
N |- if E: S1 else S2 ~ N1&N2 | e                                                   N |- while E: S ~ . | e


N,z:# |- E : t | e                                                                  N,z:t |- E : t | e,!
----------------------------- (State)                                               ------------------------ (Write)
N,z:# |- var z = E ~ z:t | e                                                        N,z:t |- z = E ~ . | e,!


N |- S ~ N1 | e     N,N1 |- S2 ~ N2 | e
--------------------------------------- (Seq)
N |- S1; S2 ~ N1,N2 | e


***** N |- S : t | e ***********************************************************************************************************************************************


N |- S ~ N' | e,ret(t)     btc(N') # ftc(t,e)     not thru(S)                       N |- S ~ N' | e,ret(t)    N |- None < t    btc(N') # ftc(t,e)    thru(S)
------------------------------------------------------------- (Result)              ------------------------------------------------------------------------ (Thru)
N |- S : t | e                                                                      N |- S : t | e

    thru(return E)                      = False
    thru(raise E)                       = False
    thru(while E: S)                    = thru(S)
    thru(if E: S1 else S2)              = thru(S1) or thru(S2)
    thru(S1; S2)                        = thru(S1) and thru(S2)
    thru(try S X else S1 finally S2)    = (thru(S;S1) or thru(X)) and thru(S2)
    thru(_)                             = True

    thru(except E as x: S X)            = thru(S) or thru(X)
    thru(.)                             = False


TODO:
    - Distinguishing required and available (defaulted) class/protocol attributes
    - Check subtyping (not equality) among overridden methods in classes
    - Witness translation
    - Automatic lifting of 's' to str (subtyping?)
    - Automatic lifting of int,... etc to (int|u) (subtyping?)
    - Static deadlock detection
    - Protocols as types, with existential quantification
    - Struct cases (and pattern-matching)
    - Type parameter variances
    - Higher-order polymorphism
    - Type macros / abstract types / associated types
    - Kind correctness
    - Read state effect (distinguish state effects per data structure?)
    - Clean up row order (l-to-r or r-to-l)
    - Read MPJ's Parametric Type Classes


NOTES:
    - Named structs are gone! Their equivalents are obtained by classes inheriting from "struct".
    - Static methods in protocols must mention Self, or else they would be ambiguous (see translation into classes)
    - Methods that mention Self in a negative position *must* be static in order to preserve type soundness
    - Static methods (or just methods that mention Self negatively) must only be selected by class.
    - The [q] part in class, protocol and extension is required, but can be left out (and inferred) in actor and def(s).
    - Unambiguity in type schemes: for each [q]=>t it must hold that fv(q) <= fv(t)  (not checked here)
    - Structs, classes and protocols have no ambiguity problems since q is always explicit there and the dom(q) are all in the resulting type.
    - Consistency requirement on extensions not checked here (from Haskell): if  N |- t impl p  and  N |- p(p')  then  N |- t impl u'
        - Alternatively: if  N |- t ~ extension(u)  and  N |- u < u'  then  N |- t ~ extension(u')
        - Concretely: if   c:[q]=>extension(d[o])  and  d[q']=>protocol(d'[o'])  both exist in N
                      then c:[q"]=>extension(d'[o"])  must also exist in N such that  [o/dom(q')]o' = phi(o") and  N,q,[o/dom(qd)]q' |- q"
    - Acyclic subtype/protocol hierarchy not checked here
    - Single subtype ancestry not checked here
    - Protocol attributes must be globally unique (not checked here)
    - Precondition to rule ImplExt: a unique (or best matching...) t(u) extension must exist in N (not checked here)
    - Termination requirements on q in extension c[q](o) not checked here (allow growing terms except in protocol cycles)
    - Self in the range of a substitution is forbidden but not checked here (maybe allow in covariant positions in the future)
    - Python's @classmethods are gone! Absorbed by protocols.
    - On class signatures:
        
                              Attribute         |     stored in class:  |    stored in instance:  |
                            -----------------------------------------------------------------------
                              of function type: |   <empty> (default)   |   @property             |
                                                |   @static             |                         |
                            -----------------------------------------------------------------------
                              of ground type:   |   @static             |   @property (default)   |
                            -----------------------------------------------------------------------
    
    - Protocol signatures can only use @static
    
    - Unused meta variables: d,i,s,I,J,P,U,Y


***** Syntax ***************************************************************************************************************************************************

        
Protocol names:     P
Class names:        C                                                                                   including int,bool,str,string literals,Msg,Ref,super
Type variables:     X                                                                                   includes Self

Types:              t,u     ::=     X  |  c  | EX(p)  |  e(r)->t  |  (r)  |  ?t  |  None                var, con, existential, fun, tuple/record, opt, void
Protocols:          p       ::=     P[o]
Classes:            c       ::=     C[o]                                                                including int,bool,str,string literals,Msg,Ref,super
Type orderings:     o       ::=     t,o  |  .                                                           associative

Rows:               r       ::=     h,k                                                                 associative
Head rows:          h       ::=     t,h  |  *X  |  .                                                    associative
Keyword rows:       k       ::=     x:t,k  |  **X  |  .                                                 associative, commutative\duplicates
Effects:            e       ::=     pure  |  mut[X]  |  act[X]  |  async  |  actor  |  X
Function contexts:  f       ::=     e[t]

Type schemas:       T       ::=     [q]=>t  |  t
Qua(l|nt)ifiers:    q       ::=     X(c,pi),q  |  .                                                     associative
Goals:              g       ::=     t(c,pi),g  |  .                                                     associative

Environments:       N       ::=     C:[q]=>(c;r)  |  P:[q]=>(pi;r)  |  w:[q]=>C(p)  |  w:q  |
                                    x:T  |  z:t  |  x:#  |  z:#  |  N,N  |  .                           associative, commutative\duplicates

Attribute envs:     n       ::=     x:T  |  n,n  |  .                                                   associative, commutative\duplicates

Witness variables:  v
Witness terms:      w       ::=     (subset of E)



***** Judgments ************************************************************************************************************************************************


N |- D : N'                 Declaration D generates bindings N' in environment N

N |- c ~ n                  Class type c exports attributes n

N |- w : p ~ n              Protocol p exports attributes n, if instantiated with w

N |- w : g                  Goal (constraint) g holds, as witnessed by w

N |- w : t < t'             Type (schema) T is a subtype (schema) of T' in environment N, as witnessed by w

N |- E : T | e              Expression E has type (scheme) T and effect e in environment N

N |- F : r | N'             Formal F has type row r in environment N (if updated with N')

N |- S : N' | f             Statement S generates bindings N' in environment N and function context f

N |- X : N' | f             Except clause X generates bindings N' in environment N and function context f

N |- S : t | e              Statement S returns values of type t with effect e in environment N



***** N |- D : N' **********************************************************************************************************************************************


N,v:q |- c1 ~ n1     n not in n1     N |- M : n' ~> M'     n' in [q,Self(C[dom(q)]]=>(Self)->(n,n1)
--------------------------------------------------------------------------------------------------- (Class)
N |- class C[q](c1):n,M  :  C:[q]=>(mro(c1);n,n1)  ~>  !class C[q](c):(n,M')


N,v:q |- wi : pi ~ ni / all i     n not in ni     N,v:q |- M : n' ~> M'     n' in [Self(P[dom(q)])]=>(Self)->(n,ni)
------------------------------------------------------------------------------------------------------------------------------------------ (Proto)
N |- protocol P[q](pi):n,M  :  P:[q]=>(mro(pi);n,ni)  ~>  !class P[Self,q]():(n,(v')->[v'.v/v]M',def _init_(v',v):v'.i=pi(wi);v'.v=v)


N,v:q |- w : p1 ~ n1     N,v:q |- C[dom(q)] ~ n     N,v:q |- M : n' ~> M'     n' in [Self(C[dom(q)])]=>(Self)->(n1)
---------------------------------------------------------------------------------------------------------------------------------------------- (Ext)
N |- extension C[q](p1):M  :  P_C:[q]=>C(mro(p1))  ~>  !class P_C[q](P[C[dom(q)],o]):((v')->[v'.v/v]M',def _init_(v',v):p1._init_(v',w);v'.v=v)


N' = N,v:q,bv(F,S):#,bz(S):#,_self_:Ref[X]      N' |- F : r | N1     N',N1 |- S : t | act[X]     X not in fv(N,q,r,t)
--------------------------------------------------------------------------------------------------------------------- (Actor)
N |- actor x[q](F):S  :  (x : [q]=>actor(r)->t)  ~>  actor x[dom(q)](v:q,F'):S'


N' = N,v:q,bv(F,S):#      N' |- F : r | N1 | e      N',N1 |- S : t | e
----------------------------------------------------------------------- (Def)
N |- def x[q](F):S  :  (x : [q]=>e(r)->t)  ~>  def x[dom(q)](v:q,F'):S'


N |- D1 : N1      N |- D2 : N2
------------------------------ (Decls)
N |- D1,D2 : N1,N2



***** N |- c ~ n ***********************************************************************************************************************************************


N,C:[q]=>(c;n) |- w : [o/q]q
------------------------------- (SigC)
N,C:[q]=>(c;n) |- C[o] ~ [o/q]n



***** N |- w : p ~ n *******************************************************************************************************************************************


N,P:[q]=>(pi;n) |- w : [o/q]q
------------------------------------ (SigP)
N,P:[q]=>(pi;n) |- w : P[o] ~ [o/q]n



***** N |- w : g ***********************************************************************************************************************************************


N,C:[q]=>(c;n) |- w : [o/q]q                            N,v:[q]=>C(p) |- w : [o/q]q
-------------------------------------- (WitC)           ------------------------------------- (WitP)
N,C:[q]=>(c;n) |- \x:x : C[o] ([o/q]c)                  N,v:[q]=>C(p) |- v(w) : C[o] ([o/q]p)

N,P:[q]=>(pi;n) |- w : t(P[o])                          N,P:[q]=>(pi;n) |- w : [o/q]q
------------------------------------------- (WitSub)    -------------------------------------------------- (WitEX)
N,P:[q]=>(pi;n) |- w.i : t([o/q]pi) / all i             N,P:[q]=>(pi;n) |- \x,y:x.0(y.1) : EX(P[o]) (P[o])

N |- w' : t < c    N |- w : t(pi),g                     N |- wi : t(pi) / all i     N |- w : g                     
----------------------------------- (ConsC)             -------------------------------------- (ConsP)              ----------- (Cons0)
N |- w : t(c,pi),g                                      N |- (wi,*w) : t(pi),g                                      N |- () : .


-------------- (WitHyp)
N,v:q |- v : q

N |- w : t(c,pi),g                                      N |- w : t(c,pi),g                                          N |- w : t(c,pi),g
------------------ (HypC)                               ------------------------ (HypP)                             --------------------- (Hyp1)
N |- \x:x : t < c                                       N |- w.i : t(pi) / all i                                    N |- w.*i : g / max i



***** N |- w : t < t' ******************************************************************************************************************************************


                                                                                    N |- w : t < t'    N |- w' : t' < t''
----------------- (SubRefl)                                                         ------------------------------------- (SubTrans)
N |- \x:x : t < t                                                                   N |- \x.w'(w(x)) : t < t''


N |- w : t(p)                                                                       N,p:[q]=>(pi;r) |- w : [o/q]q
------------------------- (SubPack)                                                 ---------------------------------------------------------------- (SubEX)
N |- \x:(w,x) : t < EX(p)                                                           N,p:[q]=>(pi;r) |- \x:(x.0.i,x) : EX(P[o]) < EX([o/q]pi) / all i


N |- w : (r') < (r)     N |- w' : t < t'    N |- e < e'                             N |- _self_ : Ref[X]
------------------------------------------------------- (SubFun)                    ---------------------------------------------------- (SubAsync)
N |- \x:\***y:w'(x(***w(y))) : e(r)->t < e'(r')->t'                                 N |- \x:ASYNC(_self_,x) : act[X](r)->t < async(r)->t


------------------ (SubPure)                                                        -------------------- (SubMut)
N |- pure < mut[X]                                                                  N |- mut[X] < act[X]

------------------------------------ (SubMsg)                                       ------------------------------- (SubNew)
N |- async(r)->t < act[X](r)->Msg[t]                                                N |- actor(r)->t < act[X](r)->t


N |- w : (k) < (r)                                                                  N |- w : t < t'     N |- w' : (r) < (r')
------------------------------------- (SubOptP)                                     --------------------------------------------------------- (SubRowP)
N |- \v:(None,***w(v)) : (k) < (?t,r)                                               N |- \v:(\x,***y:(w(x),***w'(y)))(***v) : (t,r) < (t',r')

N |- w : () < (k)                                                                   N |- w : t < t'     N |- w' : (k) < (k')
--------------------------------------- (SubOptK)                                   ------------------------------------------------------------ (SubRowK)
N |- \v:(x=None,**w(v)) : () < (x:?t,k)                                             N |- \v:(\x,**y:(x=w(x),**w'(y)))(**v) : (x:t,k) < (x:t',k')

N |- w : t < t'     N |- w' : (r) < (k)
----------------------------------------------------------- (SubShift)              ------------------- (SubStr)
N |- \v:(\x,***y:(x=w(x),**w'(y)))(***v) : (t,r) < (x:t',k)                         N |- \x:x : s < str


------------------ (SubOpt)                                                         --------------------- (SubNone)     
N |- \x:x : t < ?t                                                                  N |- \x:x : None < ?t



***** N |- E : T | e *******************************************************************************************************************************************


N |- E : t | e ~> E'     N |- w : t < t'     N |- e < e'                            N,x:[q]=>t |- w : [o/q]q
-------------------------------------------------------- (Sub)                      ------------------------------------------ (Inst)
N |- E : T' | e'  ~>  w(E')                                                         N,x:[q]=>t |- x : [o/q]t | e  ~>  app(x,w)


                                                                                    N |- _self_ : Ref[X]
------------------------- (Var)                                                     ------------------------------------- (Read)
N,x:t |- x : t | e  ~>  x                                                           N,z:t |- z : t | act[X]  ~>  _self_.z


N |- E : (t,r) | e                      N |- E : (t,r) | e                          N |- E : (h,x:t,k) | e
------------------ (SelHead)            ------------------- (SelTail)               ---------------------- (SelKwd...)
N |- E.0 : t | e                        N |- E.*1 : (r) | e                         N |- E.x : t | e


N |- E : t | e ~> E'    N |- t < c    N |- c ~ (x:T,n)    Self not in T-            N |- C[o] ~ (x:T,n)
------------------------------------------------------------------------ (Sel)      --------------------------------------------- (CSel)
N |- E.x : [t/Self]T | e  ~>  E'.x                                                  N |- C.x : [C[o]/Self]addself(T) | e  ~>  C.x

N |- E : t | e ~> E'    N |- w : t (p)    N |- p ~ (x:T,n)                          N |- w : C[o] (p)     N |- p ~ (x:T,n)
---------------------------------------------------------- (SelP)                   --------------------------------------------- (CSelP)
N |- E.x : [t/Self]T | e  ~>  app(w.x, E')                                          N |- C.x : [C[o]/Self]addself(T) | e  ~>  w.x

N |- E : EX(p) | e ~> E'    N |- p ~ (x:T,n)    Self not in T                       N |- w : t (P[o])     N |- P[o] ~ (x:T,n)
------------------------------------------------------------- (SelP')               ------------------------------------------ (CSelP')
N |- E.x : T | e  ~>  app(E'.0.x, E'.1)                                             N |- P.x : [t/Self]addself(T) | e  ~>  w.x



N' = N,bv(F):#,bz(N):#     N' |- F : r | N1     N',N1 |- E : t | e                  N |- E : e(r)->t | e     N |-> (A) : (r) | e
------------------------------------------------------------------ (Lam)            -------------------------------------------- (App)
N |- (lambda F: E) : e(r)->t | pure  ~>  lambda F: E'                               N |- E(A) : t | e


N |- _ : C[o] ~ (_init_:e(r)->None,n)
------------------------------------- (Cons)
N |- C : e(r)->C[o] | pure  ~>  C


N |- E : bool | e     N |- E1 : t | e     N |- E2 : t | e                           N |- S : t | e
--------------------------------------------------------- (If1)                     ----------------- (Do)                  -------------------- (None)
N |- E1 if E else E2 : t | e                                                        N |- do S : t | e                       N |- None : None | e


N |- E : t | e     N |- (A) : (r) | e                                               N |- E : (h) | e      N |- (M) : (k) | e
------------------------------------- (ETup)                                        ---------------------------------------- (EStar1)
N |- (E,A) : (t,r) | e                                                              N |- (*E,M) : (h,k) | e

N |- E : t | e     N |- (M) : (k) | e                                               N |- E : (k) | e
------------------------------------- (ERec)                                        -------------------- (EStar2)           ------------------ (ENull)
N |- (x=E,M) : (x:t,k) | e                                                          N |- (**E) : (k) | e                    N |- (.) : (.) | e


N |- E : Msg[t] | act[X]
------------------------- (Await)
N |- await E : t | act[X]



***** N |- F : r | N *******************************************************************************************************************************************


N |- x : t | N1      N,N1 |- F : r | N2                                             N |- x : (h) | N1       N,N1 |- K : k | N2
--------------------------------------- (PatTup)                                    ------------------------------------------ (PatStar1)
N |- x,F : t,r | N1,N2                                                              N |- *x,K : h,k | N1,N2

N |- x : t | N1      N,N1 |- K : k | N2                                             N |- x : (k) | N1
--------------------------------------- (PatRec)                                    ----------------- (PatStar2)
N |- x,K : x:t,k | N1,N2                                                            N |- **x : k | N1

N |- x : t | N1     N |- E : t | pure     N,N1 |- F : r | N2
------------------------------------------------------------ (PatOpt)               -------------- (PatNull)
N |- x=E,F : t,r | N1,N2                                                            N |- . : . | .


-------------------- (Bind)                                                         ------------------ (Rebind)
N,x:# |- x : t | x:T                                                                N,x:t |- x : t | .



***** N |- S : N | f *******************************************************************************************************************************************


N |- E : t | e                  N |- x : t | N'     N |- E : t | e                  N |- F : r | N'     N |- E : (r) | e
------------------- (Run)       ---------------------------------- (AssignVar)      ------------------------------------ (AssignPat)
N |- E  :  . | e[u]             N |- x = E  :  N' | e[u]                            N |- (F) = E  :  N' | e[u]

N,N' |- D : N'                  N |- E : t | e[t]
----------------- (Decl)        -------------------------- (Return)                 ------------------- (Pass)
N |- D  :  N' | f               N |- return E  :  . | e[t]                          N |- pass  :  . | f



N |- E1 : c | mut[X]    N |- c ~ (@prop x:t,r)    N |- c < object[X]     N |- E2 : t | mut[X]
--------------------------------------------------------------------------------------------- (Mut)
N | E1.x = E2  :  . | mut[X][u]


N |- E : bool | e     N |- S1 : N1 | f     N |- S2 : N2 | f                         N |- E : bool | e     N |- S : N' | f
----------------------------------------------------------- (If2)                   ------------------------------------- (While)
N |- if E: S1 else S2  :  N1&N2 | f                                                 N |- while E: S  :  . | f


N,z:# |- E : t | mut[X]     N |- _self_ : Ref[X]                                    N,z:t |- E : t | mut[X]     N |- _self_ : Ref[X]
------------------------------------------------ (State)                            ------------------------------------------------ (Write)
N,z:# |- var z = E  :  z:t | mut[X]                                                 N,z:t |- z = E  :  . | mut[X]


N |- E1 : int | act[X]     N |- _self_ : Ref[X]    N |- E2(A) : t | act[X]          N |- S : N1 | f     N,N1 |- S2 : N2 | f
-------------------------------------------------------------------------- (After)  --------------------------------------- (Seq)
N |- after E1: E2(A)  :  . | act[X][u]                                              N |- S1; S2  :  N1,N2 | f


N |- S : N1 | f    N |- X : N2 | f     N |- S1 : N1' | f    N |- S2 : N2' | f                   N |- S : N' | e[t]     N |- e < e'
----------------------------------------------------------------------------- (Try)             ---------------------------------- (SubFX)
N |- try S X else S1 finally S2 : ((N1,N1')&N2),N2' | f                                         N |- S : N' | e'[t]


***** N |- X : N | f *******************************************************************************************************************************************


N,x:C[] |- S : N1 | f    N |- X : N2 | f                                            
---------------------------------------- (Except1)                                  --------------- (Except0)
N |- except C as x: S X : N1&N2 | f                                                 N |- . : N' | f


***** N |- S : t | e *******************************************************************************************************************************************


N |- S : N' | e[t]     btc(N') # ftc(t,e)     not thru(S)                           N |- S : N' | e[t]    N |- None < t     thru(S)
--------------------------------------------------------- (Result)                  ----------------------------------------------- (Thru)
N |- S : t | e                                                                      N |- S : t | e

    thru(return E)                      = False
    thru(raise E)                       = False
    thru(while E: S)                    = thru(S)
    thru(if E: S1 else S2)              = thru(S1) or thru(S2)
    thru(S1; S2)                        = thru(S1) and thru(S2)
    thru(try S X else S1 finally S2)    = (thru(S;S1) or thru(X)) and thru(S2)
    thru(_)                             = True

    thru(except c as x: S X)            = thru(S) or thru(X)
    thru(.)                             = False


N |- S : t | mut[X]    X not in fv(N,t)
--------------------------------------- (RunST)
N |- S : t | pure



################################################################################################################################################################
################################################################################################################################################################


N,v:B(Ord) |- v._Eq_ : B(Eq)
------------------------------------------------- (SubInst)
N,v:B(Ord) |- \y:y(v._Eq_) : [A(Eq)]=>t[A] < t[B]
-------------------------------------------------------------- (SubGen)
N |- \x:\v:(\y:y(v._Eq_))(x)  : [A(Eq)]=>t[A] < [B(Ord)]=>t[B]
N |- \x:\v:    x(v._Eq_)      : [A(Eq)]=>t[A] < [B(Ord)]=>t[B]


N,v:A(Eq) |- \a,b: Eq._eq_(a,b) : (A,A)->bool  ~>  \a,b: v._eq_(a,b)
------------------------------------------------------------------------- (Gen)
N |- \a,b: Eq._eq_(a,b) : [A(Eq)]=>(A,A)->bool  ~>  \v':\a,b: v'._eq_(a,b)         N |- \x:\v:x(v._Eq_) : [A(Eq)]=(A,A)->bool[A] < [B(Ord)]=>(B,B)->bool[B]
----------------------------------------------------------------------------------------------------------------------------------------------------------- (Sub)
N |- \a,b: Eq._eq_(a,b) : [B(Ord)]=>(B,B)->bool  ~>  (\x:\v:x(v._Eq_))(\v':\a,b: v'._eq_(a,b))
N |- \a,b: Eq._eq_(a,b) : [B(Ord)]=>(B,B)->bool  ~>      \v:(\v':\a,b: v'._eq_(a,b))(v._Eq_)
N |- \a,b: Eq._eq_(a,b) : [B(Ord)]=>(B,B)->bool  ~>      \v:\a,b: v._Eq_._eq_(a,b)

###################################################################################

class Apa [X(Eq)]:
    a : X
    def _init_(self,a:X):                                           : [X(Eq), Self(Apa[X])] => (Self, X) -> None
        self.a = a
    def apa(self, y:X):                                             : [X(Eq), Self(Apa[X])] => (Self, X) -> bool
        return Eq._eq_(self.a, y)

class Bepa [X(Ord)] (Apa[X]):       [X(Ord)]=>Bepa[X](Apa[X]) |-
    b : X
    def _init_(self, a:X, b:X):                                     : [X(Ord), Self(Bepa[X])] => (Self, X, X) -> None
        Apa._init_(self,a)
        self.b = b
    def bepa(self, y:X):                                            : [X(Ord), Self(Bepa[X])] => (Self, X) -> bool
        return self.apa(y) or Ord._lt_(self.b, y)
        
=====>

class Apa [X]:
    a : X
    def _init_(self, w:Eq[X], a:X):                                 : [X, S(Apa[X])] => (S, Eq[X], X) -> None
        self.a = a
    def apa(self, w:Eq[X], y:X):                                    : [X] => (Apa, Eq[X], X) -> bool
        return w._eq_(self.a, y)


class Bepa [X] (Apa[X]):            id:[X]=>(Ord[X],Apa[X])->Bepa[X] |-
    b : X
    def _init_(self, w:Ord[X], a:X, b:X):                           : [X] => (Bepa, Ord[X], X, X) -> None
        Apa._init_(self, _Ord_to_Eq(w), a)
        self.b = b
    def bepa(self, w:Ord[X], y:X):                                  : [X] => (Bepa, Ord[X], X) -> bool
        return self.apa(_Ord_to_Eq(w), y) or w._lt_(self.b, y)

###################################################################################

protocol Container[A(Eq)]:                      Container:[A(Eq)]=>(_contains_:(A)->bool) |-
    _contains_ : (A) -> bool
    def _contains_(self:Self, a:A):
        return False

protocol Maximal[A(Ord)] (Container[A]):        ..., Maximal:[A(Ord)]=>(max:()->A), [A(Ord)]=>Maximal[A](Container[A]) |-
    max : () -> A

extension list[A(Ord)] (Maximal[A]):
    def _contains_(self:Self, a:A):
        for i in range(len(self)):
            if Eq._eq_(self[i], a):
                return True
        return False
    def max(self:Self):
        m = None
        for i in range(len(self)):
            if Ord._lt_(m, self[i]):
                m = self[i]
        return m

=====>

class Container[S,A]:                           Container:[S,A]=>(w1:Eq[A], _contains_:(S,A)->bool) |-
    w1 : Eq[A]
    _contains_ : (S, A) -> bool
    def _contains_(wit:Self, self:S, a:A):
        return False

class Maximal[S,A] (Container[S,A]):            ..., Maximal:[S,A]=>(w2:Ord[A], max:(S)->A), id:[S,A]=>(Container[S,A])->Maximal[S,A] |-
    w2 : Ord[A]
    max : (S, A) -> A

class Maximal_list[A] (Maximal[list[A],A]):
    def _init_(wit:Self, w:Ord[A]):
        wit.w1 = w
        wit.w2 = w
    def _contains_(wit:Self, self:S, a:A):
        for i in range(len(self)):
            if wit.w1._eq_(self[i], a):
                return True
        return False
    def max(wit:Self, self:S):
        m = None
        for i in range(len(self)):
            if wit.w2._lt_(m, self[i]):
                m = self[i]
        return m
    

###################################################################################


CONV(cs) =
    CONV(ds,cs)                     for ds in lbr(cs)
    CONV(d,cs)                      for d in rbr(cs)
    class nm(cs) tpar(cs) base(cs):
      d : d tpar(d)                 for d in newrbr(cs) + last(cs)
      def __init__(x,xs):           where x,xs = par(cs)
        x.d = nm(d,ds,cs)(x,xs)     for d,ds in lbr(cs)
        x.d = nm(d,cs)(x,xs)        for d in rbr(cs)
        x.d = c                     for (d,c) in binds(cs)
      ...

br(c)       =       { cs,c | cs in br(d) } U { d,c | d in ds }      if c(d,ds)
lbr(c..)    =       br(d)                                           
rbr(c..)    =       {ds}                                            
newrbr(c)   =       rbr(c)
newrbr(cs)  =       {}

br(c) = lbr(c..) = rbr(c..) = {}                                    otherwise

c << d      =       if c(d',ds) and d' = d or d' << d

nm(c)       =       _c
nm(cs,ds)   =       nm(cs)nm(ds)

base(c)     =       (d[S,o])                                        if c[q](d[o],ds)
            =       ()                                              otherwise
base(cs,c)  =       (nm(cs)[dom(q)])                                if tpar(c) = [q]

last(c)     =       {}
last(cs,c)  =       {c}

binds(c,cs) =       cs `zip` rh(cs)

rh(cs,d,c)  =       rh(cs,c),c                                      if c << d
            =       rh(cs,d),c                                      otherwise
rh(cs)      =       cs

tpar(cs,c)  =       [Self,q]                                        if c[q](...)

par(d,c,cs) =       par(c,cs)                                       if c << d
            =       d,par(c,cs)                                     otherwise
par(xs)     =       cs

################################################################

A       B       C       D       E       F       G       H
 \     .         \     .         \     .         \     .
  \   .           \   .           \   .           \   .
    I               J               K               L
     \             .                 \             .
       \         .                     \         .
         \     .                         \     .
            M                               N
             \                             .
                \                       .
                   \                 .
                      \           .
                         \     .
                            O

A[X,Y]()     B[Z]()     C()     D()     E()     F()     G()     H()
    I[X](A[X,int],B[str])   J[Z](C,D)      K(E,F)          L(G,H)
            M[X](I[bool],J[(X,X)])                     N(K,L)
                            O(M,N)

-----------------------------------------------------------------

# CONV(A)                                               lbr(A) = {}                 rbr(A) = {}
    class A[X,Y]():                                     par(A) = A
        def __init__(A):                                rh(.) = .
            pass

... B - G similarly ...

# CONV(I)                                               lbr(I) = {}                 rbr(I) = {B}
    # CONV(B,I)                                         lbr(B) = {}                 rbr(B) = {}
        class B_I[X](B[str]):                           par(B,I) = B,par(I) = B,I
            I : I
            def __init__(B,I):                          rh(I) = I
                B.I = I
    class I[X](A[X,int]):                               par(I) = I
        B : B[str]
        def __init__(I):                                rh(.) = .
            I.B = B_I(@X,I)

# CONV(J)                                               lbr(J) = {}                 rbr(J) = {D}
    # CONV(D,J)                                         lbr(D) = {}                 rbr(D) = {}
        class D_J(D):                                   par(D,J) = D,par(J) = D,J
            J : J
            def __init__(D,J):                          rh(J) = J
                D.J = J
    class J(C):                                         par(J) = J
        D : D
        def __init__(J):                                rh(.) = .
            J.D = D_J(D)

# CONV(K)                                               lbr(K) = {}                 rbr(K) = {F}
    # CONV(F,K)                                         lbr(F) = {}                 rbr(F) = {}
        class F_K(F):                                   par(F,K) = F,par(K) = F,K
            K : K
            def __init__(F,K):                          rh(K) = K
                F.K = K
    class K(E):                                         par(K) = K
        F : F
        def __init__(K):                                rh(.) = .
            K.F = F_K(K)

# CONV(L)                                               lbr(L) = {}                 rbr(L) = {H}
    # CONV(H,L)                                         lbr(H) = {}                 rbr(H) = {}
        class H_L(H):                                   par(H,L) = H,par(L) = L
            L : L
            def __init__(H,L):                          rh(L) = L
                H.L = L
    class L(G):                                         par(L) = L
        H : H
        def __init__(L):                                rh(.) = .
            L.H = H_L(L)

# CONV(M)                                               lbr(M) = {B,I}              rbr(M) = {J}
    # CONV(B,I,M)                                       lbr(B) = {}                 rbr(B) = {}
        class B_I_M[X](B_I[bool]):                      par(B,I,M) = B,par(I,M) = B,par(M) = B,M
            M : M
            def __init__(B,M):                          rm(I,M) = rm(M),M = M,M
                B.I = M
                B.M = M
    # CONV(J,M)                                         lbr(J) = {}                 rbr(J) = {D}
        # CONF(D,J,M)                                   lbr(D) = {}                 rbr(D) = {}
            class D_J_M[X](D_J[(X,X)]):                 par(D,J,M) = D,par(J,M) = D,J,par(M) = D,J,M
                M : M
                def __init__(D,J,M):                    rh(J,M) = rh(J),M = J,M
                    D.J = J
                    D.M = M
        class J_M[X](J[(X,X)]):                         par(J,M) = J,par(M) = J,M
            M : M
            def __init__(J,M):                          rh(M) = M
                J.D = D_J_M(J,M)
                J.M = M
    class M[X](I[bool]):                                par(M) = M
        J : J
        def __init__(M):                                rh(.) = .
            M.B = B_I_M(@bool,M)
            M.J = J_M(M)

# CONV(N)                                               lbr(N) = {F,K}              rbr(N) = {L}
    # CONV(F,K,N)                                       lbr(F) = {}                 rbr(F) = {}
        class F_K_N(F_K):                               par(F,K,N) = F,par(K,N) = F,par(N) = F,N
            N : N
            def __init__(F,N):                          rh(K,N) = rn(N),N = N,N
                F.K = N
                F.N = N
    # CONV(L_N)                                         lbr(L) = {}                 rbr(L) = {H}
        # CONV(H,L,N)                                   lbr(H) = {}                 rbr(H) = {}
            class H_L_N(H_L):                           par(H,L,N) = H,par(L,N) = H,L,par(N) = H,L,N
                N : N
                def __init__(H,L,N):                    rh(L,N) = rn(L),N = L,N
                    H.L = L
                    H.N = N
        class L_N(L):                                   par(L,N) = L,par(N) = L,N
            N : N
            def __init__(L,N):                          rh(N) = N
                L.H = H_L_N(L,N)
                L.N = N
    class N(K):                                         par(N) = N
        L : L
        def __init__(N):                                rh(.) = .
            N.F = F_K_N(N)
            N.L = L_N(N)


# CONV(O)                                               lbr(O) = {B,I,M,O | J,M}    rbr(O) = {N}
    # CONV(B,I,M,O)                                     lbr(B) = {}                 rbr(B) = {}
        class B_I_M_O (B_I_M):                          par(B,I,M,O) = B,par(I,M,O) = B,par(M,O) = B,par(O) = B,O
            O : O
            def __init__(B,O):                          rh(I,M,O) = rh(I,O),O = rh(O),O,O = O,O,O 
                B.I = O
                B.M = O
                B.O = O
    # CONV(J,M,O)                                       lbr(J) = {}                 rbr(J) = {D}
        # CONV(D,J,M,O)                                 lbf(D) = {}                 rbr(D) = {}
            class D_J_M_O(D_J_M):                       par(D,J,M,O) = D,par(J,M,O) = D,J,par(M,O) = D,J,par(O) = D,J,O
                O : O
                def __init__(D,J,O):                    rh(J,M,O) = rh(J,O),O = R(J),O,O = J,O,O
                    D.J = J
                    D.M = O
                    D.O = O
        class J_M_O(J_M):                               par(J,M,O) = J,par(M,O) = J,par(O) = J,O
            O : O
            def __init__(J,O):                          rh(M,O) = rh(O),O = O,O
                J.D = D_J_M_O(J,O)
                J.M = O
                J.O = O
    # CONV(N,O)                                         lbr(N) = {F,K}              rbr(N) = {L}
        # CONV(F,K,N,O)                                 lbr(F) = {}                 rbr(F) = {}
            class F_K_N_O(F_K_N):                       par(F,K,N,O) = F,par(K,N,O) = F,par(N,O) = F,N,par(O) = F,N,O
                O : O
                def __init__(F,N,O):                    rh(K,N,O) = rn(K,N),O = rn(N),N,O = N,N,O
                    F.K = N
                    F.N = N
                    F.O = O
        # CONV(L,N,O)                                   lbr(L) = {}                 rbr(L) = {H}
            # CONV(H,L,N,O)                             lbr(H) = {}                 rbr(H) = {}
                class H_L_N_O(H_L_N):                   par(H,L,N,O) = H,par(L,N,O) = H,L,par(N,O) = H,L,N,par(O) = H,L,N,O
                    O : O
                    def __init(H,L,N,O):                rh(L,N,O) = rn(L,N),O = rn(L),N,O = L,N,O
                        H.L = L
                        H.N = N
                        H.O = O
            class L_N_O(L_N):                           par(L,N,O) = L,par(N,O) = L,N,par(O) = L,N,O
                O : O
                def __init__(L,N,O):                    rh(N,O) = rh(N),O = N,O
                    L.H = H_L_N_O(L,N,O)
                    L.N = N
                    L.O = O
        class N_O(N):                                   par(N,O) = N,par(O) = N,O
            O : O
            def __init__(N,O):                          rh(O) = O
                N.F = F_K_N_O(N,O)
                N.L = L_N_O(N,O)
                N.O = O
    class O(M):                                         par(O) = O
        N : N
        def __init__(O):                                rh(.) = .
            O.B = B_I_M_O(O)
            O.J = J_M_O(O)
            O.N = N_O(O)


################################################################

protocol Eq:
    @staticmethod
    _eq_ : (Self,Self) -> bool

protocol Ord (Eq):
    @staticmethod
    _le_ : (Self,Self) -> bool
    def _eq_(x,y):
        return _le_(x,y) and _le_(y,x)

protocol Hmm (Eq):
    def _eq_(x,y):
        return False
    
class Apa (Ord)
    def _eq_(x,y):
        return x.apa == y.apa or super._eq_(x,y)
    def _le_(x,y):
        return x.apa <= y.apa

class Bepa (Apa,Hmm,Ord):
    def _le_(x,y):
        return x.bepa <= y.bepa

self,other : Bepa
Eq._eq_(self,other)

==============>      mro: Bepa, Apa, Hmm, Ord, Eq

class Eq[S]:
    _eq_ : (S,S) -> bool

class Ord[S] (Eq[S]):
    _le_ : (S,S) -> bool
    def _eq_(wit,x,y):
        return wit._le_(x,y) and wit._le_(y,x)

class Hmm[S] (Eq[S]):
    def _eq_(wit,x,y):
        return False

class Apa ():
    pass
class Ord_Apa[S(Apa)] (Ord[S]):                             # NOT class Ord_Apa[] (Ord[Apa]), which would preclude inheritance (in Bepa)
    def _eq_(wit,x,y):
        return x.apa == y.apa or super._eq_(x,y)            # super == super(Ord_Apa,cls), i.e., it passes on cls to Ord._eq_!
    def _le_(wit,x,y):
        return x.apa <= y.apa

class Bepa (Apa):
    pass                                                    # NOTE: [S(Bepa)]=>Ord_Bepa[S] </ [S(Apa)]=>Ord_Apa[S]
class Hmm_Bepa[S(Bepa)] (Hmm[S]):
    _Ord : Ord_Bepa
    def __init__(wit):
        wit._Ord = Ord_Bepa(wit)
    def _eq_(wit,a,b):
        return False
class Ord_Bepa[S(Bepa)] (Ord[S]):
    _Hmm : Hmm_Bepa
    _eq_ = Ord_Apa._eq_                                     # [S(Apa)]=>(S,S)->bool < [S(Bepa)]=>(S,S)->bool            ??????????????
    def _le_(wit,x,y):
        return x.bepa <= y.bepa

self,other : Bepa

_eq_(self,other) ==> 
Ord_Bepa._eq_(Ord_Bepa,self,other) ==> 
Ord_Apa._eq_(Ord_Bepa,self,other) ==> 
... Ord._eq_(Ord_Bepa,self,other) ==>
... Ord_Bepa._le_(Ord_Bepa,self_other) and ... ==>
... self.bepa <= y.bepa ...

==============>

struct Eq_class;                                                            struct Ord_class;
typedef struct Eq_class *Eq_class;                                          typedef struct Ord_class *Ord_class;
                                                                            $bool Ord$_eq_(Ord_class, $WORD, $WORD);

struct Eq_class {                                                           struct Ord_class { // extends Eq_class
    $bool(*_eq_)(Eq_class,$WORD,$WORD);                                         $bool (*_eq_)(Ord_class,$WORD,$WORD);
};                                                                              $bool (*_le_)(Ord_class,$WORD,$WORD);
                                                                            };

                                                                            $bool Ord$_eq_(Ord_class cls, $WORD x, $WORD y) {
                                                                                return cls->_le_(cls,x,y) && cls->_le_(cls,y,x);
                                                                            }

/////

struct Apa;                                                                 struct Bepa;
typedef struct Apa *Apa;                                                    typedef struct Bepa *Bepa;

struct Apa {                                                                struct Bepa { // extends Apa
    Apa_class __class__;                                                        Bepa_class __class__;
    $int apa;                                                                   $int apa;
};                                                                              $int bepa;
                                                                            };

/////

struct Ord_Apa;                                                             struct Ord_Bepa;
typedef struct Ord_Apa *Ord_Apa;                                            typedef struct Ord_Bepa *Ord_Bepa;
$bool Apa$_eq_(Ord_Apa, Apa, Apa);                                          $bool Bepa$_le_(Ord_Bepa, Bepa, Bepa);
$bool Apa$_le_(Ord_Apa, Apa, Apa);

struct Ord_Apa { // extends Ord_class                                       struct Ord_Bepa { // extends Ord_class
    $bool (*_eq_)(Ord_Apa,Apa,Apa);                                             $bool (*_eq_)(Ord_Bepa,Bepa,Bepa);
    $bool (*_le_)(Ord_Apa,Apa,Apa);                                             $bool (*_le_)(Ord_Bepa,Bepa,Bepa);
    $bool (*Ord_Apa$super$_eq_)(Ord_Apa,Apa,Apa);                               $bool (*Ord_Apa$super$_eq_)(Ord_Bepa,Bepa,Bepa);
} Ord_Apa = {                                                               } Ord_Bepa = {
    Apa$_eq_,       // _eq_                                                     Apa$_eq_,       // _eq_
    Apa$_le_,       // _le_                                                     Bepa$_le_,      // _le_
    Ord$_eq_        // Ord_Apa$super$_eq_                                       Ord$_eq_        // Ord_Apa$super$_eq_
};                                                                          };

$bool Apa$_eq_(Ord_Apa cls, Apa x, Apa y) {
    return x->apa==y->apa || cls->Ord_Apa$super$_eq_(cls,x,y);
}
$bool Apa$_le_(Ord_Apa cls, Apa x, Apa y) {                                 $bool Bepa$_le_(Ord_Bepa cls, Bepa x, Bepa x) {
    return x->apa <= y->apa;                                                    return x->bepa <= y->bepa;
}                                                                           }

/////
    
Bepa self;
Bepa other;
w_Ord_Bepa = &Ord_Bepa;

w_Ord_Bepa->_eq_(w_Ord_Bepa,self, other) ==> 
Apa$_eq_(w_Ord_Bepa, self, other) ==> 
... w_Ord_Bepa->Ord_Apa$super$_eq_(w_Ord_Bepa, self, other)
... Ord$_eq_(w_Ord_Bepa, self, other) ==>
... w_Ord_Bepa->_le_(w_Ord_Bepa, self, other) and ... ==>
... Bepa$_le_(w_Ord_Bepa, self, other) and ... ==>
... self.bepa <= other.bepa ...

########################
protocol Eq ()
protocol Ord (Eq)
protocol Rational ()
protocol Integer (Rational)
class tt ()
extension tt (Integer,Rational)
extension tt (Ord)
---
MRO(Eq)         = [Eq]
MRO(Ord)        = [Ord,Eq]
MRO(Rational)   = [Rational]
MRO(Integer)    = [Integer,Rational]
MRO(tt)         = [tt]
MRO(tt_1)       = [tt_1,tt,Integer,Rational]
MRO(tt_2)       = [tt_2,tt_1,tt,Integer,Rational,Ord,Eq]

MRO(tt_1)       = [tt,Integer,Rational]
MRO(tt_2)       = [tt,Ord,Eq]
########################

****************************************************************************************************************************************************************
****************************************************************************************************************************************************************

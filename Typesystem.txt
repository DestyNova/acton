TODO:
    - Distinguishing required and available (defaulted) class/protocol attributes
    - Check subtyping (not equality) among overridden methods in classes
    - Witness translation
    - Automatic lifting of 's' to str (subtyping?)
    - Automatic lifting of int,... etc to (int|u) (subtyping?)
    - Static deadlock detection
    - Protocols as types, with existential quantification
    - Struct cases (and pattern-matching)
    - Type parameter variances
    - Higher-order polymorphism
    - Type macros / abstract types / associated types
    - Kind correctness
    - Read state effect (distinguish state effects per data structure?)
    - Clean up row order (l-to-r or r-to-l)
    - Read MPJ's Parametric Type Classes


NOTES:
    - Named structs are gone! Their equivalents are obtained by classes, either lacking __init__ or more explicitly decorated @immutable.
    - Static methods in protocols must mention Self, or else they would be ambiguous (see translation into classes)
    - The [q] part in class, protocol and extension is required, but can be left out (and inferred) in actor and def(s).
    - Unambiguity in type schemes: for each [q]=>t it must hold that ftv(q) <= ftv(t)  (not checked here)
    - Structs, classes and protocols have no ambiguity problems since q is always explicit there and the dom(q) are all in the resulting type.
    - Consistency requirement on extensions not checked here (from Haskell): if  N |- t impl u  and  N |- u < u'  then  N |- t impl u'
        - Alternatively: if  N |- t ~ extension(u)  and  N |- u < u'  then  N |- t ~ extension(u')
        - Concretely: if   c:[q]=>extension(d[o])  and  d[q']=>protocol(d'[o'])  both exist in N
                      then c:[q"]=>extension(d'[o"])  must also exist in N such that  [o/dom(q')]o' = phi(o") and  N,q,[o/dom(qd)]q' |- q"
    - Acyclic subtype/protocol hierarchy not checked here
    - Single subtype ancestry not checked here
    - Protocol attributes must be globally unique (not checked here)
    - Precondition to rule ImplExt: a unique (or best matching...) t(u) extension must exist in N (not checked here)
    - Termination requirements on q in extension c[q](o) not checked here (allow growing terms except in protocol cycles)
    - Self in the range of a substitution is forbidden but not checked here (maybe allow in covariant positions in the future)
    - The notation c[q] as a *type* is a bit sloppy and should be improved
    - On class/protocol signatures:

        Every object attribute falls into one of two categories, depending on where it is stored (in the object instance itself or in its 
        class). For function-valued class attributes (i.e., methods) there are furthermore three sub-cases: (1) the method expects the 
        effective object instance to be passed as an additional first parameter, (2) the method expects the effective class as an extra 
        first parameter, and (3) the method expects no extra parameters at all. Case (1) is the default, whereas cases (2) and (3) must 
        be marked with the special decorators @classmethod and @staticmethod respectively.
        
        When invoked on an object instance, the three method cases imply three distinct invocation (or rather attribute selection) 
        mechanisms: the object itself is automatically supplied as the first argument in case (1), in case (2) it is the class of the 
        instance that is automnatically supplied, and no extra arguments are passed in case (3). When selected directly from a class, 
        the extra parameter gets exposed in the returned method if it is of type (1), but not in the other cases (the class being selected
        from is automatically supplied as the first argument in case (2)).
        
        In the type signature of a class, the storage category of each attribute must be revealed, together with the chosen selection 
        mechanism in case of class-based attributes of function type. Not only is this important for class documentation purposes, the
        revealed info also determines if an attribute can be inherited, and if so what its actual parameter list should be. If the 
        decorators @classmethod and @staticmethod are retained on the level of types, we can indicate class-based methods of type (2) and
        (3), but not any of the other categories. While it is true that most class attributes have function type and most instance attributes
        are ground, the other two combinations are not uncommon. We will therefore need a way to complement the type signatures of a class 
        with the missing storage information.
        
        Proposal: introduce new mutually exclusive decorators @classattr and @instattr to capture the missing storage dimension. For a 
        ground attribute this would simply indicate where the values are found. Likewise, writing @instattr on an attribute of method type
        would tell that it is stored with every instance and not with the common class. But even decorating a method with @classattr might
        be meaningful, as we could make this imply a method of type (1) above (@classattr would thus outrule @classmethod and @staticmethod).
        
        Defaults could moreover be assigned on basis of type, so that @instattr would be assumed if a ground attribute lacks decoration, but
        @classattr would be implied if the attribute is a function. This way we could write class signature without any decorators for the
        typical cases, and only be required to be explicit about storage if a class has a ground class attribute (write @classattr) or a 
        function in its instance data (decorate the attribute signature with @instattr). Or, as before, if we want a class method to be
        invoked using any of the special mechanisms (2) or (3) above, in which case we must provide the @classmethod or @staticmethod 
        decorators instead of the default @classattr.
        
        Furthermore, in a concrete class declaration, the compiler is of course able to infer the storage decorators of attributes depending 
        on how they are defined. So an assignment in a class body leads to a @classattr attribute even if its type is ground, and assignment
        attributes of self forces @instattr to be inserted on the attribute signatures, irrespective of their type. The distinction between 
        @classattr and @instattr is thus must important when a class signature is used in isolation, i.e., when the *interface* of a class
        is considered. There, on the other hand, the @classattr/@instattr distinction is crucial.
        
        In summary:
        
                              Attribute         |     stored in class:      |    stored in instance:    |
                            -----------------------------------------------------------------------------
                                                |   @classattr (default)    |   @instattr               |
                              of function type: |   @classmethod            |                           |
                                                |   @staticmethod           |                           |
                            -----------------------------------------------------------------------------
                               of ground type:  |   @classattr              |   @instattr (default)     |
                            -----------------------------------------------------------------------------
    
    
    - Unused meta variables: g,h,k,v,w,J,R,U,Y


***** Syntax *******************************************************************************************************************************************************

                    
Type constants:     c,d                                                                                 including int,bool,str,literals,Msg,Ref

Type variables:     X                                                                                   includes Self

Types:              t       ::=     X  |  u  |  e(p,r)->t  |  (p)  |  (r)  |  ?t  |  None  |  @u        var, con, fun, tuple, record, opt, void, class type

Constructor types:  u       ::=     c[o]

Ordered types:      o       ::=     t,o  |  .                                                           associative

Position rows:      p       ::=     t,p  |  *X  |  .                                                    associative

Type environments:  n       ::=     x:T,n  |  .                                                         associative, commutative, disjoint

Type rows:          r       ::=     x:T,r  |  **X  |  .                                                 associative, commutative\duplicates

Effect rows:        e       ::=     ret(t),e  |  sync,e  |  async,e  |  act,e  |  !,e  |  X  |  .       associative, commutative\duplicates

Qua(l|nt)ifiers:    q       ::=     X(o)  |  q,q  |  .                                                  associative

Schemas:            T       ::=     [q] => t  |  t

Constraints:        C       ::=     t(o)  |  C,C  |  .                                                  associative, commutative

Type info:          I       ::=     class(o):n  |  protocol(o):n  |  extension(o)

eNvironments:       N       ::=     x:T  |  z:t  |  x:#  |  z:#  |  c:[q]=>I  |  t(o)  |  N,N  |  .     associative, commutative\duplicates


***** Judgments ****************************************************************************************************************************************************


N |- D : N'                 Declaration D generates bindings N' in environment N

N |- t ~ I                  Type t is defined as I in environment N

N |- t impl u               Type t implements protocol u in environment N

N |- t < u                  Type t is a subtype of u in environment N

N |- C                      Constraint C holds in environment N

N |- E : T | e              Expression E has type (scheme) T in environment N and effect context e

N |- F : p | N' | e         Formal parameter F has type p in environment N (if updated with N') and effect context e

N |- K : r | N' | e         Keyword parameter K has type r in environment N (if updated with N')and effect context e

N |- x : t | N'             Variable x has type t in environment N (if updated with N')

N |- S ~ N' | e             Statement S generates bindings N' in environment N and effect context e

N |- S : t | e              Statement S returns values of type t in environment N and effect context e


***** N |- D : N' **************************************************************************************************************************************************


N' = N,q,Self(c[q]),_class_:c[q]     N' |- u ~ class(o):n'      N' |- ui ~ protocol(oi):ni     N' |- M : n2 | e      n2 in n',U(ni),n
------------------------------------------------------------------------------------------------------------------------------------- (Class)
N |- class c[q](u,ui):n,M  :  c:[q]=>class(o,MRO(oi)):(n',U(ni),n)

N' = N,q,Self(c[q])     N' |- ui ~ protocol(oi):ni      N' |- M : n2 | e      n2 in U(ni),n
------------------------------------------------------------------------------------------- (Protocol)
N |- protocol c[q](ui):n,M  :  c:[q]=>protocol(MRO(oi)):(U(ni),n)


N' = N,q,Self(c[q])     N' |- c[q] ~ protocol(o):n     N' |- ui ~ protocol(oi):ni      N' |- M : n2 | e     n2 in U(ni)
----------------------------------------------------------------------------------------------------------------------- (ExtProto)
N |- extension c[q](ui):M  :  c:[q]=>extension(ui)

N' = N,q,Self(c[q])     N' |- c[q] ~ class(o):n     N' |- ui ~ protocol(oi):ni      N' |- M : n2 | e     n2 in U(ni)
-------------------------------------------------------------------------------------------------------------------- (ExtClass)
N |- extension c[q](ui):M  :  c:[q]=>extension(ui)


N' = N,q,bv(F,K,S):#,dzv(N,S):#,_self_:Ref    N' |- F : p ~ N1 | e    N',N1 |- K : r ~ N2 | e    N',N1,N2 |- S : t | e
---------------------------------------------------------------------------------------------------------------------- (Actor)
N |- actor x[q](F,K):S  :  x: [q] => e',act(p,r)->t

N' = N,q,bv(F,K,S):#    N' |- F : p ~ N1 | e     N',N1 |- K : r ~ N2 | e     N',N1,N2 |- S : t | e
-------------------------------------------------------------------------------------------------- (SyncMeth)
N |- sync def x[q](F,K):S  :  x: [q] => e',sync(p,r)->t

N' = N,q,bv(F,K,S):#    N' |- F : p ~ N1 | e     N',N1 |- K : r ~ N2 | e     N',N1,N2 |- S : t | e
-------------------------------------------------------------------------------------------------- (AsyncMeth)
N |- async def x[q](F,K):S  :  x: [q] => e',async(p,r)->Msg[t]

N' = N,q,bv(F,K,S):#    N' |- y,F : Self,p ~ N1 | e     N',N1 |- K : r ~ N2 | e     N',N1,N2 |- S : t | e
--------------------------------------------------------------------------------------------------------- (InstMeth)
N |- @instmethod def x[q](y,F,K):S  :  x : [q] => e(p,r)->t

N' = N,q,bv(F,K,S):#    N' |- _class_ : u | e     N' |- F : @u,p ~ N1 | e     N',N1 |- K : r ~ N2 | e     N',N1,N2 |- S : t | e
------------------------------------------------------------------------------------------------------------------------------- (ClassMeth)
N |- @classmethod def x[q](y,F,K):S  :  x : [q] => e(p,r)->t

N' = N,q,bv(F,K,S):#    N' |- F : p ~ N1 | e     N',N1 |- K : r ~ N2 | e     N',N1,N2 |- S : t | e
-------------------------------------------------------------------------------------------------- (Def)
N |- def x[q](F,K):S  :  x : [q] => e(p,r)->t


N |- D1 : N1      N |- D2 : N2
------------------------------ (Defs)
N |- D1,D2 : N1,N2


***** N |- t ~ I ***************************************************************************************************************************************************


phi = [o/dom(q)]     N,c:[q]=>I |- phi(q)
----------------------------------------- (Info)
N,c:[q]=>I |- c[ti] ~ phi(I)


***** N |- t impl u ************************************************************************************************************************************************


N |- t ~ extension(u,o)      N |- u ~ protocol(o'):n                                N,t(u,o) |- u ~ protocol(o):n
---------------------------------------------------- (ImplExt)                      ----------------------------- (ImplHyp)
N |- t impl u                                                                       N,t(u,o) |- t impl u


N |- t impl u       N |- u < u'
------------------------------- (ImplSub)
N |- t impl u'


***** N |- t < t' **************************************************************************************************************************************************


phi = [o/dom(q)]     N,q' |- phi(q)     N,q' |- phi(t) < t'                         N |- u ~ protocol(u',o):n     N |- u' ~ protocol(o'):n'
----------------------------------------------------------- (SubScheme)             ------------------------------------------------------- (SubProto)
N |- [q]=>t < [q']=>t'                                                              N |- u < u'


N |- u ~ class(u',o):n      N |- u' ~ class(o'):n'                                  N,t(u,o) |- u ~ class(o'):n
-------------------------------------------------- (SubClass)                       --------------------------- (SubHyp)
N |- u < u'                                                                         N,t(u,o) |- t < u


N |- p' < p     N |- r' < r     N |- t < t'                                         x:t,r "canonically ordered"
------------------------------------------- (SubFun)                                -------------------------------- (SubArgs)
N |- e(p,r)->t < e(p',r')->t'                                                       N |- e(p,x:t,r)->t < e(p,t,r)->t


N |- p < p'                                                                         N |- r < r'
--------------- (SubTup)                                                            --------------- (SubRec)
N |- (p) < (p')                                                                     N |- (r) < (r')

N |- t < t'     N |- p < p'                                                         N |- T < T'     N |- r < r'
--------------------------- (SubRowP)                                               --------------------------- (SubRowR)
N |- t,p < t',p'                                                                    N |- x=t,r < x=t',r'

N |- . < p                                                                          N |- . < r
------------- (SubLacksP)                                                           --------------- (SubLacksR)
N |- . < ?t,p                                                                       N |- . < x:?t,r


N |- u ~ class(u',o):n      N |- u' ~ class(o'):n'
-------------------------------------------------- (SubAt)                          ----------- (SubOpt)                -------------- (SubNone)
N |- @u < @u'                                                                       N |- t < ?t                         N |- None < ?t


N |- t1 < t2      N |- t2 < t3
------------------------------ (SubTrans)                                           ---------- (SubRefl)
N |- t1 < t3                                                                        N |- t < t


***** N |- C *******************************************************************************************************************************************************


                                            N |- C1      N |- C2                    N |- t < u      N |- t(o)               N |- t impl u     N |- t(o)
------ (Con0)       --------- (Con1)        -------------------- (Con2)             ------------------------- (ConSub)      --------------------------- (ConImpl)
N |- .              N |- t(.)               N |- C1,C2                              N |- t(u,o)                             N |- t(u,o)


***** N |- E : T | e ***********************************************************************************************************************************************


N |- E : t | e     N |- t < u
----------------------------- (Sub)
N |- E : u | e


N,q |- E : t | e      dtv(q) not in ftv(N)                                          N |- E : [q] => t     phi = [o/dom(q)]     N |- phi(q)
------------------------------------------ (Gen)                                    ------------------------------------------------------ (Inst)
N |- E : [q] => t | e                                                               N |- E : phi(t)


------------------ (Var1)                                                           -------------------- (Read)
N,x:T |- x : T | e                                                                  N,z:t |- z : t | e,!

N |- u' ~ protocol(o):(x:T,n)     N |- w : u impl u'     x staticm                  Self is guaranteed to appear in T, so the expected type of x
------------------------------------------------------------------ (Var2)           uniquely determines u. Also, u' is determined by x (and T).
N |- x : [u/Self]T  ~>  w.x                                                         By uniqueness of instances, u' then determines witness w.


N |- u' ~ protocol(o):(x:T,n)     N |- w : u impl u'     N |- E : u      x not staticm
-------------------------------------------------------------------------------------- (SelP)
N |- E.x : [u/Self]T  ~>  w.x(E)

N |- E : u | e     N |- u ~ class(o):(x:T,n)    x not staticm
------------------------------------------------------------- (SelC1)
N |- E.x : [u/Self]T | e

N |- E : @u     N |- u ~ class(o):(x:e(p,r)->t,n)     x instm                       N |- E : @u     N |- u ~ class(o):(x:T,n)     x not instm
-------------------------------------------------------------- (SelC2)              --------------------------------------------------------- (SelC3)
N |- E.x : [u/Self]e(Self,p,r)->t | e'                                              N |- E.x : [u/Self]T | e


N |- E : (x:T,r) | e                                                                N |- c[o] ~ class(o'):n
-------------------- (Sel)                                                          ------------------------ (At)
N |- E.x : T | e                                                                    N |- c : @c[o]

                                        
N |- F : p ~ N1 | e'     N,N1 |- K : r ~ N2 | e'     N,N1,N2 |- E : t | e'
-------------------------------------------------------------------------- (Lam)
N |- (lambda F,K: E) : e'(p,r)->t | e


N |- E : e(p,r)->t | e     N |-> (A) : (p) | e     N |- (M) : (r) | e
--------------------------------------------------------------------- (App)
N |- E(A,M) : t | e


N |- c[o] ~ class(o'):((_init_:e(p,r)->None):n)      N |- (A) : p | e     N |- (M) : (r) | e
-------------------------------------------------------------------------------------------- (Cons)
N |- c(A,M) : c[o] | e


N |- E : bool | e     N |- E1 : t | e     N |- E2 : t | e
--------------------------------------------------------- (If1)
N |- E1 if E else E2 : t | e


N |- E : t | e     N |- (A) : (p) | e                                               N |- E : (p) | e
------------------------------------- (Tup)                                         ------------------- (Star1)
N |- (E,A) : (p,t) | e                                                              N |- (*E) : (r) | e

C,C' | N |- E : t | e     N |- (M) : (r) | e                                        N |- E : (r) | e
-------------------------------------------- (Rec)                                  -------------------- (Star2)            ------------------ (Null)
N |- (x=E,M) : (r,x:gen(N,C,t,C')) | e                                              N |- (**E) : (r) | e                    N |- (.) : (.) | e


N |- E : Msg(t) | e                                                                 N |- S : t | e
------------------------- (Await)                                                   ----------------- (Do)
N |- await E : t | e,sync                                                           N |- do S : t | e


-------------------- (None)
N |- None : None | e


***** N |- F : p | N | e *******************************************************************************************************************************************


N |- x : t | N1     N,N1 |- F : p | N2 | e                                          N |- x : (p) | N1
------------------------------------------ (TupVar)                                 -------------------- (TupStar)
N |- x,F : p,t ~ N1,N2 | e                                                          N |- *x : p | N1 | e

N |- x : t | N1     N |- E : t | e     N,N1 |- F : p | N2 | e
------------------------------------------------------------- (TupOpt)              ------------------ (TupNull)
N |- x=E,F : p,t | N1,N2 | e                                                        N |- . : . | . | e


***** N |- K : r | N | e *******************************************************************************************************************************************


N |- x : T | N1     N,N1 |- F : r | N2 | e                                          N |- x : (r) | N1
------------------------------------------ (RecVar)                                 --------------------- (RecStar)
N |- x,K : r,x:T | N1,N2 | e                                                        N |- **x : r | N1 | e

N |- x : T | N1     N |- E : T | e     N,N1 |- F : r | N2 | e
------------------------------------------------------------- (RecOpt)              ------------------ (RecNull)
N |- x=E,K : r,x:T | N1,N2 | e                                                      N |- . : . | . | e


***** N |- x : t | N ***********************************************************************************************************************************************


-------------------- (Bind)                                                         ------------------ (Rebind)
N,x:# |- x : T | x:T                                                                N,x:t |- x : t | .


***** N |- P : t | N | e *******************************************************************************************************************************************


N |- x : t | N1                         N |- F : p | N1 | e                         N |- K : r | N1 | e
------------------- (PatVar)            ----------------------- (PatTup)            ----------------------- (PatRec)
N |- x : t | N1 | e                     N |- (F) : (p) | N1 | e                     N |- (K) : (r) | N1 | e


***** N |- S ~ N | e ***********************************************************************************************************************************************


N |- E : t | e              N |- P : t ~ N' | e     N |- E : t | e                  N,N' |- D : N'
-------------- (Run)        -------------------------------------- (Assign)         --------------- (Def)
N |- E ~ . | e              N |- P = E ~ N' | e                                     N |- D ~ N' | e


N |- E : t | e
---------------------------- (Return)                                               ----------------- (Pass)
N |- return E ~ . | e,ret(t)                                                        N |- pass ~ . | e


N |- E1 : u | e,!    N |- u(object)    N |- u ~ class(o):x:@instattr t,n    N |- E2 : t | e,!
--------------------------------------------------------------------------------------------- (Mut)
N | E1.x = E2 ~ . | e,!


N |- E : bool | e     N |- S1 ~ N1 | e     N |- S2 ~ N2 | e                         N |- E : bool | e     N |- S ~ N' | e
----------------------------------------------------------- (If2)                   ------------------------------------- (While)
N |- if E: S1 else S2 ~ N1&N2 | e                                                   N |- while E: S ~ . | e


N,z:# |- E : t | e                                                                  N,z:t |- E : t | e,!
----------------------------- (State)                                               ------------------------ (Write)
N,z:# |- var z = E ~ z:t | e                                                        N,z:t |- z = E ~ . | e,!


N |- S ~ N1 | e     N,N1 |- S2 ~ N2 | e
--------------------------------------- (Seq)
N |- S1; S2 ~ N1,N2 | e


***** N |- S : t | e ***********************************************************************************************************************************************


N |- S ~ N' | e,ret(t)     btc(N') # ftc(t,e)     not thru(S)                       N |- S ~ N' | e,ret(t)    N |- None < t    btc(N') # ftc(t,e)    thru(S)
------------------------------------------------------------- (Result)              ------------------------------------------------------------------------ (Thru)
N |- S : t | e                                                                      N |- S : t | e

    thru(return E)                      = False
    thru(raise E)                       = False
    thru(while E: S)                    = thru(S)
    thru(if E: S1 else S2)              = thru(S1) or thru(S2)
    thru(S1; S2)                        = thru(S1) and thru(S2)
    thru(try S X else S1 finally S2)    = (thru(S;S1) or thru(X)) and thru(S2)
    thru(_)                             = True

    thru(except c as x: S X)            = thru(S) or thru(X)
    thru(.)                             = False



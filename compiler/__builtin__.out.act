## Built-in types ##################################################################################

class int:
  pass

class float:
  pass

class complex:
  pass

class bool:
  pass

class str:
  capitalize   : () -> str
  center       : (int,str) -> str
  count        : (str,int,int) -> int
  ends$wselfh     : (str,int,int) -> bool
  expandtabs   : (int) -> str
  find         : (str,int,int) -> int
  index        : (str,int,int) -> int
  isalnum      : () -> bool
  isalpha      : () -> bool
  isascii      : () -> bool
  isdecimal    : () -> bool
  islower      : () -> bool
  isprintable  : () -> bool
  isspace      : () -> bool
  istitle      : () -> bool
  isupper      : () -> bool
  join         : (Iterator[str]) -> str
  ljust        : (int,str) -> str
  lower        : () -> str
  lstrip       : (str) -> str
  partition    : (str) -> (str,str,str)
  replace      : (str,str,int) -> str
  rfind        : (str,int,int) -> int
  rindex       : (str,int,int) -> int
  rjust        : (int,str) -> str
  rpartition   : (str) -> (str,str,str)
  rstrip       : (str) -> str
  split        : (str,int) -> list[str]
  splitlines   : () -> list[str]
  starts$wselfh   : (str,int,int) -> bool
  strip        : (str) -> str
  upper        : () -> str
  str_zfill    : (str,int) -> str

class Slice:
  pass
  
class Iterator[A] ():
  next : () -> A
  
class list[A] ():
  copy : () -> list[A]

class Msg[A] ():
  pass

## General protocols ###############################################################################

class Eq[S] ():
  def __init__($wself):
      pass
  __eq__       : (S,S) -> bool
  __ne__       : (S,S) -> bool            # has default defn

class Ord[S] (Eq[S]):
  def __init__($wself):
      Eq.__init__($wself)

  __lt__       : (S,S) -> bool
  __le__       : (S,S) -> bool
  __gt__       : (S,S) -> bool            # has default defn
  __ge__       : (S,S) -> bool            # has default defn
      
class Logical[S] ():
  def __init__($wself):
      pass

  __and__     : (S,S) -> S
  __or__      : (S,S) -> S
  __xor__     : (S,S) -> S

class Plus[S] ():
  def __init__($wself):
      pass

  __add__      : (S,S) -> S

class Minus[S] ():
  def __init__($wself):
      pass

  __sub__      : (S,S) -> S

class Hashable[S] (Eq[S]):
  def __init__($wself):
      pass

  __hash__     : (S) -> int

class dict[A,B] ():                     # Note: A(Hashable) removed here
  pass

class set[A] ():                        # Note: A(Hashable) removed here
  pass

class Boolean[S] ():
  def __init__($wself):
      pass

  __bool__   : (S) -> bool

class Boolean$int (Boolean[int]):
  def __init__($wself):
      Boolean.__init__($wself)

  def __bool__($wself, self):
    return Eq$int$witness.__ne__(self,0)

class Boolean$list[A] (Boolean[list[A]]):
  def __init__($wself):
      Boolean.__init__($wself)

  def __bool__($wself, self):
    return Ord$int$witness.__gt__(Collection$list$witness.__len__(self,0))


## Collection protocols ############################################################################

class Indexed[S,A,B] ():
  w$Eq$A       : Eq[A]
  def __init__($wself, w$Eq$A : Eq[A]):
      $wself.w$Eq$A = w$Eq$A
  
  __getitem__  : (S,A) -> B
  __setitem__  : (S,A,B) -> None 
  __delitem__  : (S,A) -> None
  
class Sliceable[S,A] (Indexed[S,int,A]):
  def __init__($wself):
      Indexed.__init__($wself, Eq$int())

  __getslice__ : (S,Slice) -> S
  __setslice__ : [X] => (Iterable[X,A],S,Slice,X) -> None
  __delslice__ : (S,Slice) -> None
  
class Iterable[S,A] ():
  def __init__($wself):
      pass

  __iter__     : (S) -> Iterator[A]

class Collection[S,A] (Iterable[S,A]):
  def __init__($wself):
      Iterable.__init__($wself)

  __fromiter__ : [X] => (Iterable[X,A],X) -> S
  __len__      : (S) -> int
  
class Container[S,A]] (Collection[S,A]):
  w$Eq$A          : Eq[A]
  def __init__($wself, w$Eq$A : Eq[A]):
      Colleaction.__init__($wself)
      $wself.w$Eq$A = w$Eq$A
  
  __contains__    : (S,A) -> bool  
  __containsnot__ : (S,A) -> bool


#   Indexed         Iterable
#    |               |
#    |               |
#   Sliceable       Collection      Plus
#    |               |               |
#    |               |               |
#   Sequence <-------- <--------------

class Sequence[S,A] (Sliceable[S,A]):
  w$Collection$Sequence : Collection[S,A]
  w$Plus$Sequence       : Plus[S]:
  def __init__($wself, w$Collection$Sequence : Collection[S,A], w$Plus$Sequence : Plus[S]):
      Sliceable.__init__($wself)
      $wself.w$Collection$Sequence = w$Collection$Sequence
      $wself.w$Plus$Sequence = w$Plus$Sequence
  
  __reversed__ : (S) -> Iterator[A] 
  insert      : (S,int,A) -> None
  append      : (S,A) -> None   
  reverse     : (S,) -> None       


#   Iterable
#    |
#    |
#   Collection
#    |
#    |
#   Container       Indexed
#    |               |
#    |               |
#   Mapping <---------

class Mapping[S,A,B] (Container[S,A]):
  w$Indexed$Mapping   : Indexed[S,A,B])
  def __init($wself, w$Eq$A : Eq[A], w$Indexed$Mapping : Indexed[S]):
      Container.__init__($wself, w$Eq$A)
      $wself.w$Indexed$Mapping = w$Indexed$Mapping
  
  get         : (S,A,B) -> B
  keys        : (S) -> Iterator[A]
  values      : (S) -> Iterator[Bw$Eq$A]:
  items       : (S) -> Iterator[(A,B)]
  update      : [X] => (Iterable[X,(A,B)],S,X) -> None  
  popitem     : (S) -> (A,B)
  setdefault  : (S,A,B) -> None


#   Iterable
#    |
#    |
#   Collection      Eq
#    |               |
#    |               |
#   Container       Ord             Logical         Minus
#    |               |               |               |
#    |               |               |               |
#   Set <------------- <-------------- <--------------

class Set[S,A] (Container[S,A]):
  w$Ord$Set       : Ord[S]
  w$Logical$Set   : Logical[S]
  w$Minus$Set     : Minus[S]
  def __init__($wself, w$Eq$A : Eq[A], w$Ord$Set : Ord[S], w$Logical$Set : Logical[S], w$Minus$Set : Minus[S]):
      Container.__init__($wself, w$Eq$A)
      $wself.w$Ord$Set = w$Ord$Set
      $wself.w$Logical$Set = w$Logical$Set
      $wself.w$Minus$Set = w$Minus$Set
  
  isdisjoint  : (S,S) -> bool
  add         : (S,A) -> None  
  discard     : (S,A) -> None  
  pop         : (S) -> A 


## Number protocols ################################################################################

#   Eq ______________               Plus            Minus
#    |               |               |               |
#    |               |               |               |
#   Ord             Complex <--------- <--------------
#    |               |
#    |               |
#   Real <------------
#    |
#    |
#   Rational        Logical
#    |               |
#    |               |
#   Integral <--------

class Complex[S] (Eq[S]):
    $Plus       : Plus[S]
    $Minus      : Minus[S]
  
    __complex__ : (S) -> complex
    __bool__    : (S) -> bool

    __mul__     : (S,S) -> S
    __truediv__ : (S,S) -> S
    __pow__     : (S,S) -> S

    __neg__     : (S) -> S
    __pos__     : (S) -> S
  
    real        : [X] => (Real[X],S) -> X
    imag        : [X] => (Real[X],S) -> X
    __abs__     : [X] => (Real[X],S) -> X

    conjugate   : (S) -> S

class Plus$Complex[S] (Plus[S]):
    $Complex    : Complex[S]

class Minus$Complex[S] (Minus[S]):
    $Complex    : Complex[S]

##

class Real[S] (Ord[S]):
    $Complex    : Complex[S]         # Eq implemented in both parents!
  
    __float__   : (S) -> float

    __trunc__   : [X] => (Integral[X],S) -> X
    __floor__   : [X] => (Integral[X],S) -> X
    __ceil__    : [X] => (Integral[X],S) -> X
    __round__   : [X] => (Integral[X],S) -> X

class Complex$Real[S] (Complex[S]):
    $Real       : Real[S]

class Plus$Real[S] (Plus$Complex[S]):
    $Real       : Real[S]

class Minus$Real[S] (Minus$Complex[S]):
    $Real       : Real[S]

##

class Rational[S] (Real[S]):
    numerator    : [X] => (Integral[X],S) -> X
    denominator  : [X] => (Integral[X],S) -> X

class Complex$Rational[S] (Complex$Real[S]):
    $Rational    : Rational[S]

class Plus$Rational[S] (Plus$Real[S]):
    $Rational    : Rational[S]

class Minus$Rational[S] (Minus$Real[S]):
    $Rational    : Rational[S]

##

class Integral[S] (Rational[S]):
    $Logical     : Logical[S]
  
    __int__      : (S) -> int
    __index__    : (S) -> int

    __divmod__   : (S,S) -> (S,S)
    __floordiv__ : (S,S) -> S
    __mod__      : (S,S) -> S

    __lshift__   : (S,S) -> S
    __rshift__   : (S,S) -> S

    __invert__   : (S) -> S

class Logical$Integral[S] (Logical[S]):
    $Integral    : Integral[S]

class Complex$Integral[S] (Complex$Rational[S]):
    $Integral    : Integral[S]

class Plus$Integral[S] (Plus$Rational[S]):
    $Integral    : Integral[S]

class Minus$Integral[S] (Minus$Rational[S]):
    $Integral    : Integral[S]



## Extensions ######################################################################################

extension int (Integral):
    # __mod__, numerator, __trunc__, __le__, __eq__, __or__, __mul__, __add__, __sub__

# ==> 

class Integral$int (Integral[int]):
    def __init__($wself):
        $wself.$Complex  = Complex$int($wself)
        $wself.$Logical  = Logical$int($wself)
    # __mod__, numerator, __trunc__, __le__, __eq__

class Logical$int (Logical$Integral[int]):
    def __init__($wself, w$Integral : Integral$int):
        $wself.$Integral = w$Integral
    # __or__

class Complex$int (Complex$Integral[int]):
    def __init__($wself, w$Integral : Integral$int):
        $wself.$Plus     = Plus$int($wself, w$Integral)
        $wself.$Minus    = Minus$int($wself, w$Integral)
        $wself.$Real     = w$Integral
        $wself.$Rational = w$Integral
        $wself.$Integral = w$Integral
    def __eq__($wself, a, b):
        return $wself.$Integral.__eq__(a, b)
    # __mul__

class Plus$int (Plus$Integral[int]):
    def __init__($wself, w$Complex : Complex$int, w$Integral : Integral$int):
        $wself,$Complex  = w$Complex
        $wself.$Real     = w$Integral
        $wself.$Rational = w$Integral
        $wself.$Integral = w$Integral
    # __add__

class Minus$int (Minus$Integral[int]):
    def __init__($wself, w$Complex : Complex$int, w$Integral : Integral$int):
        $wself,$Complex  = w$Complex
        $wself.$Real     = w$Integral
        $wself.$Rational = w$Integral
        $wself.$Integral = w$Integral
    # __sub__

####

extension int (Complex):
    # __mul__, __eq__, __add__, __sub__
...
extension int (Integral):
    # __mod__, numerator, __trunc__, __le__, __or__
    
# ==>

class Complex$int (Complex[int]):
    def __init__($wself):
        $wself.$Plus     = Plus$int($wself)
        $wself.$Minus    = Minus$int($wself)
    # __mul__, __eq__

class Plus$int (Plus$Complex[int]):
    def __init__($wself, w$Complex : Complex$int):
        $wself.$Complex  = w$Complex
    # __add__

class Minus$int (Minus$Complex[int]):
    def __init__($wself, w$Complex : Complex$int):
        $wself,$Complex  = w$Complex
    # __sub__

class Integral$int (Integral[int]):
    def __init__($wself):
        $wself.$Complex  = Complex$int()
        $wself.$Logical  = Logical$int($wself)
    def __eq__($wself, a, b):
        return $wself.$Complex.__eq__(a, b)
    # __mod__, numerator, __trunc__, __le__

class Logical$int (Logical$Integral[int]):
    def __init__($wself, w$Integral : Integral$int):
        $wself.$Integral = w$Integral
    # __or__

####

extension int (Eq):
    # __eq__
...
extension int (Complex):
    # __mul__, __add__, __sub__
...
extension int (Integral):
    # __mod__, numerator, __trunc__, __le__, __or__
    
# ==>

class Eq$int (Eq[int]):
    def __init__($wself):
        pass
    # __eq__

class Complex$int (Complex[int]):
    def __init__($wself):
        $wself.$Eq       = Eq$int()
        $wself.$Plus     = Plus$int($wself)
        $wself.$Minus    = Minus$int($wself)
    def __eq__($wself, a, b):
        ...     # code copied form Eq$int
    # __mul__

class Plus$int (Plus$Complex[int]):
    def __init__($wself, w$Complex : Complex$int):
        $wself.$Complex  = w$Complex
    # __add__

class Minus$int (Minus$Complex[int]):
    def __init__($wself, w$Complex : Complex$int):
        $wself,$Complex  = w$Complex
    # __sub__

class Integral$int (Integral[int]):
    def __init__($wself):
        $wself.$Complex  = Complex$int()
        $wself.$Logical  = Logical$int($wself)
    def __eq__($wself, a, b):
        ...     # code copied form Eq$int
    # __mod__, numerator, __trunc__, __le__

class Logical$int (Logical$Integral[int]):
    def __init__($wself, w$Integral : Integral$int):
        $wself.$Integral = w$Integral
    # __or__

####

extension int (Real):
    # __trunc__, __le__, __eq__, __mul__, __add__, __sub__
...
extension int (Integral):
    # __mod__, numerator, __or__
    
# ==>

class Real$int (Real[int]):
    def __init__($wself):
        $wself.$Complex  = Complex$int($wself)
    # __trunc__, __le__, __eq__

class Complex$int (Complex$Real[int]):
    def __init__($wself, w$Real : Real$int):
        $wself.$Plus     = Plus$int($wself, w$Integral)
        $wself.$Minus    = Minus$int($wself, w$Integral)
        $wself.$Real     = w$Real
    def __eq__($wself, a, b):
        return $wself.$Real.__eq__(a, b)
    # __mul__

class Plus$int (Plus$Real[int]):
    def __init__($wself, w$Complex : Complex$int, w$Integral : Integral$int):
        $wself,$Complex  = w$Complex
        $wself.$Real     = w$Integral
    # __add__

class Minus$int (Minus$Real[int]):
    def __init__($wself, w$Complex : Complex$int, w$Integral : Integral$int):
        $wself,$Complex  = w$Complex
        $wself.$Real     = w$Integral
    # __sub__

class Integral$int (Integral[int]):
    def __init__($wself):
        $wself.$Complex  = $wself.$Real
        $wself.$Logical  = Logical$int($wself)
    def __trunc__($wself, a):
        ...     # code copied from Real$int
    def __le__($wself, a, b):
        ...     # code copied from Real$int
    def __eq__($wself, a, b):
        ...     # code copied from Real$int
    # __mod__, numerator

class Logical$int (Logical$Integral[int]):
    def __init__($wself, w$Integral : Integral$int):
        $wself.$Integral = w$Integral
    # __or__


################


class Collection$list (Collection[list[A],A]):
    w$Sequence$list : Sequence$list[A]
    def __init__($wself, w$Sequence$list):
        Collection.__init__($wself)
        $wself.w$Sequence$list = w$Sequence$list
class Plus$list (Plus[list[A],A]):
    w$Sequence$list : Sequence$list[A]
    def __init__($wself, w$Sequence$list):
        Plus.__init__($wself)
        $wself.w$Sequence$list = w$Sequence$list
class Sequence$list[A] (Sequence[list[A],A]):
    def __init__($wself):
        Sequence.__init__(Collection$list($wself), Plus$list($wself))

class Container$list[A(Eq)] (Container[A]):
    w$Sequence$list : Sequence[list[A],A]
    def __init__($wself, w$Eq$A : Eq[A]):
        Container.__init__($wself, w$Eq$A)
        $wself.w$Sequence$list = Sequence$list()

class Indexed$dict (Indexed[dict[A,B],A,B]):
    w$Mapping$dict : Mapping$dict[A,B]
    def __init__($wself, w$Eq$A : Eq[A], w$Mapping$dict : Mapping$dict[A,B]):
        Indexed.__init__($wself, w$Eq$A)
        $wself.w$Mapping_dict = w$Mapping$dict
class Mapping$dict[A,B] (Mapping[dict[A,B],A,B]):
    w$Hashable$A : Hashable[A]
    def __init__($wself, w$Hashable$A : Hashable[A]):
        Mapping.__init__($wself, Indexed$dict($wself,w$Hashable$A))
        $wself.w$Hashable$A = w$Hashable$A

class Ord$set (Ord[set[A]]):
    w$Set$set : Set$set[A]
    def __init__($wself, w$Set$set):
        Ord.__init__($wself)
        $wself.w$Set$set = w$Set$set
class Locical$set (Logical[set[A]]):
    w$Set$set : Set$set[A]
    def __init__($wself, w$Set$set):
        Logical.__init__($wself)
        $wself.w$Set$set = w$Set$set
class Minus$set (Minus[set[A]]):
    w$Set$set : Set$set[A]
    def __init__($wself, w$Set$set):
        Minus.__init__($wself)
        $wself.w$Set$set = w$Set$set
class Set$set[A] (Set[set[A],A]):
    w$Hashable$A : Hashable[A]
    def __init__($wself, w$Hashable$A : Hashable[A]):
        Set.__init__($wself, w$Hashable$A, Ord$set($wself), Logical$set($wself), Minus$set($wself))
        $wself.w$Hashable$A = w$Hashable$A

class Iterable$Iterator[A] (Iterable[Iterator[A],A]):
    def __init__($wself):
        Iterable.__init__($wself)

class Ord$str (Ord[str]):
    def __init__($wself):
        Ord.__init__($wself)

class Container$str (Container[str,str]):
    def __init__($wself):
        Container.__init__($wself, Eq$str())

class Sliceable$str (Sliceable[str,str]):
    def __init__($wself):
        Sliceable.__init__($wself)

class Plus$str (Plus[str]):
    def __init__($wself):
        Plus.__init__($wself)

class Hashable$str (Hashable[str]):
    def __init__($wself):
        Hashable.__init__($wself)


class Hashable$int (Hashable[int]):
    def __init__($wself):
        Hashable.__init__($wself)

class Plus$float (Plus[float]):
    w$Real$float : Real$float
    def __init__($wself, w$Real$float):
        $wself.w$Real$float = w$Real$float
class Minus$float (Minus[float]):
    w$Real$float : Real$float
    def __init__($wself, w$Real$float):
        $wself.w$Real$float = w$Real$float
class Complex$float (Complex[float]):
    w$Real$float : Real$float
    def __init__($wself, w$Real$float):
        Complex.__init__($wself, Plus$float($wself), Minus$float($wself))
        $wself.w$Real$float = w$Real$float
class Real$float (Real[float]):
    def __init__($wself):
        Real.__init__($wself, Complex$float($wself))

class Hashable$float (Hashable[float]):
    def __init__($wself):
        Hashable.__init__($wself)

## Builtin functions #####################################################

def abs[X,Y](w1:Complex[X], w2:Real[Y], x : X) -> Y:
    return w1.__abs__@[Y](w2, x)
    
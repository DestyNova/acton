## Built-in types ##################################################################################

class int:
  pass

class float:
  pass

class complex:
  pass

class bool:
  pass

class str:
  capitalize   : () -> str
  center       : (int,str) -> str
  count        : (str,int,int) -> int
  ends$wselfh     : (str,int,int) -> bool
  expandtabs   : (int) -> str
  find         : (str,int,int) -> int
  index        : (str,int,int) -> int
  isalnum      : () -> bool
  isalpha      : () -> bool
  isascii      : () -> bool
  isdecimal    : () -> bool
  islower      : () -> bool
  isprintable  : () -> bool
  isspace      : () -> bool
  istitle      : () -> bool
  isupper      : () -> bool
  join         : (Iterator[str]) -> str
  ljust        : (int,str) -> str
  lower        : () -> str
  lstrip       : (str) -> str
  partition    : (str) -> (str,str,str)
  replace      : (str,str,int) -> str
  rfind        : (str,int,int) -> int
  rindex       : (str,int,int) -> int
  rjust        : (int,str) -> str
  rpartition   : (str) -> (str,str,str)
  rstrip       : (str) -> str
  split        : (str,int) -> list[str]
  splitlines   : () -> list[str]
  starts$wselfh   : (str,int,int) -> bool
  strip        : (str) -> str
  upper        : () -> str
  str_zfill    : (str,int) -> str

class Slice:
  pass
  
class Iterator[A] ():
  next : () -> A
  
class list[A] ():
  copy : () -> list[A]

class Msg[A] ():
  pass

## General protocols ###############################################################################

class Eq[S] ():
  def __init__($wself):
      pass
  __eq__       : (S,S) -> bool
  __ne__       : (S,S) -> bool            # has default defn

class Ord[S] (Eq[S]):
  def __init__($wself):
      Eq.__init__($wself)

  __lt__       : (S,S) -> bool
  __le__       : (S,S) -> bool
  __gt__       : (S,S) -> bool            # has default defn
  __ge__       : (S,S) -> bool            # has default defn
      
class Logical[S] ():
  def __init__($wself):
      pass

  __and__     : (S,S) -> S
  __or__      : (S,S) -> S
  __xor__     : (S,S) -> S

class Plus[S] ():
  def __init__($wself):
      pass

  __add__      : (S,S) -> S

class Minus[S] ():
  def __init__($wself):
      pass

  __sub__      : (S,S) -> S

class Hashable[S] (Eq[S]):
  def __init__($wself):
      pass

  __hash__     : (S) -> int

class dict[A,B] ():                     # Note: A(Hashable) removed here
  pass

class set[A] ():                        # Note: A(Hashable) removed here
  pass

class Boolean[S] ():
  def __init__($wself):
      pass

  __bool__   : (S) -> bool

class Boolean$int (Boolean[int]):
  def __init__($wself):
      Boolean.__init__($wself)

  def __bool__($wself, self):
    return Eq$int$witness.__ne__(self,0)

class Boolean$list[A] (Boolean[list[A]]):
  def __init__($wself):
      Boolean.__init__($wself)

  def __bool__($wself, self):
    return Ord$int$witness.__gt__(Collection$list$witness.__len__(self,0))


## Collection protocols ############################################################################

class Indexed[S,A,B] ():
  w$Eq$A       : Eq[A]
  def __init__($wself, w$Eq$A : Eq[A]):
      $wself.w$Eq$A = w$Eq$A
  
  __getitem__  : (S,A) -> B
  __setitem__  : (S,A,B) -> None 
  __delitem__  : (S,A) -> None
  
class Sliceable[S,A] (Indexed[S,int,A]):
  def __init__($wself):
      Indexed.__init__($wself, Eq$int())

  __getslice__ : (S,Slice) -> S
  __setslice__ : (S,Slice,Iterable$opaque[A]) -> None
  __delslice__ : (S,Slice) -> None
  
class Iterable[S,A] ():
  def __init__($wself):
      pass

  __iter__     : (S) -> Iterator[A]

class Iterable$opaque[A] ():            # Exists S:
    proto      : Iterable[S,A]
    impl       : S

class Collection[S,A] (Iterable[S,A]):
  def __init__($wself):
      Iterable.__init__($wself)

  __fromiter__ : (Iterable$opaque[A]) -> S
  __len__      : (S) -> int
  
class Container[S,A]] (Collection[S,A]):
  w$Eq$A          : Eq[A]
  def __init__($wself, w$Eq$A : Eq[A]):
      Colleaction.__init__($wself)
      $wself.w$Eq$A = w$Eq$A
  
  __contains__    : (S,A) -> bool  
  __containsnot__ : (S,A) -> bool


#   Indexed         Iterable
#    |               |
#    |               |
#   Sliceable       Collection      Plus
#    |               |               |
#    |               |               |
#   Sequence <-------- <--------------

class Sequence[S,A] (Sliceable[S,A]):
  w$Collection$Sequence : Collection[S,A]
  w$Plus$Sequence       : Plus[S]:
  def __init__($wself, w$Collection$Sequence : Collection[S,A], w$Plus$Sequence : Plus[S]):
      Sliceable.__init__($wself)
      $wself.w$Collection$Sequence = w$Collection$Sequence
      $wself.w$Plus$Sequence = w$Plus$Sequence
  
  __reversed__ : (S) -> Iterator[A] 
  insert      : (S,int,A) -> None
  append      : (S,A) -> None   
  reverse     : (S,) -> None       


#   Iterable
#    |
#    |
#   Collection
#    |
#    |
#   Container       Indexed
#    |               |
#    |               |
#   Mapping <---------

class Mapping[S,A,B] (Container[S,A]):
  w$Indexed$Mapping   : Indexed[S,A,B])
  def __init($wself, w$Eq$A : Eq[A], w$Indexed$Mapping : Indexed[S]):
      Container.__init__($wself, w$Eq$A)
      $wself.w$Indexed$Mapping = w$Indexed$Mapping
  
  get         : (S,A,B) -> B
  keys        : (S) -> Iterator[A]
  values      : (S) -> Iterator[Bw$Eq$A]:
  items       : (S) -> Iterator[(A,B)]
  update      : (S,Iterable$opaque[(A,B)]) -> None  
  popitem     : (S) -> (A,B)
  setdefault  : (S,A,B) -> None


#   Iterable
#    |
#    |
#   Collection      Eq
#    |               |
#    |               |
#   Container       Ord             Logical         Minus
#    |               |               |               |
#    |               |               |               |
#   Set <------------- <-------------- <--------------

class Set[S,A] (Container[S,A]):
  w$Ord$Set       : Ord[S]
  w$Logical$Set   : Logical[S]
  w$Minus$Set     : Minus[S]
  def __init__($wself, w$Eq$A : Eq[A], w$Ord$Set : Ord[S], w$Logical$Set : Logical[S], w$Minus$Set : Minus[S]):
      Container.__init__($wself, w$Eq$A)
      $wself.w$Ord$Set = w$Ord$Set
      $wself.w$Logical$Set = w$Logical$Set
      $wself.w$Minus$Set = w$Minus$Set
  
  isdisjoint  : (S,S) -> bool
  add         : (S,A) -> None  
  discard     : (S,A) -> None  
  pop         : (S) -> A 


## Number protocols ################################################################################

#   Eq ______________               Plus            Minus
#    |               |               |               |
#    |               |               |               |
#   Ord             Complex <--------- <--------------
#    |               |
#    |               |
#   Real <------------
#    |
#    |
#   Rational        Logical
#    |               |
#    |               |
#   Integral <--------

class Complex[S] (Eq[S]):
  w$Plus$Complex   : Plus[S]
  w$Minus$Complex  : Minus[S]
  def __init__($wself, w$Plus$Complex : Plus[S], w$Minus$Complex : Minus[S]):
      Eq.__init__($wself)
      $wself.w$Plus$Complex = w$Plus$Complex
      $wself.w$Minus$Complex = w$Minus$Complex
  
  __complex__  : (S) -> complex
  __bool__     : (S) -> bool

  __mul__      : (S,S) -> S
  __truediv__  : (S,S) -> S
  __pow__      : (S,S) -> S

  __neg__      : (S) -> S
  __pos__      : (S) -> S
  
  real         : (S) -> Real$opaque
  imag         : (S) -> Real$opaque
  __abs__      : (S) -> Real$opaque

  conjugate    : (S) -> S


class Complex$opaque ():            # Exists S:
  proto        : Complex[S]
  impl         : S

class Real[S] (Ord[S]):
  w$Complex$Real : Complex[S]       # Eq implemented in both parents!
  def __init__($wself, w$Complex$Real : Complex[S]):
      Ord.__init__($wself)
      $wself.w$Complex$Real = w$Complex$Real
  
  __float__    : (S) -> float

  __trunc__    : (S) -> Integral$opaque
  __floor__    : (S) -> Integral$opaque
  __ceil__     : (S) -> Integral$opaque
  __round__    : (S) -> Integral$opaque


class Real$opaque ():           # Exists S:
  proto        : Real[S]
  impl         : S

class Rational[S] (Real[S]):
  def __init__($wself, w$Complex$Real : Complex[S]):
      Real.__init__($wself, w$Complex$Real)

  numerator    : (S) -> Integral$opaque
  denominator  : (S) -> Integral$opaque

class Integral[S] (Rational[S]):
  w$Logical$Integral : Logical[S]
  def __init__($wself, w$Complex$Real : Complex[S], w$Logical$Integral : Logical[S]):
      Rational.__init__($wself, w$Complex$Real)
      $wself.w$Logical$Integral = w$Logical$Integral
  
  __int__      : (S) -> int
  __index__    : (S) -> int

  __divmod__   : (S,S) -> (S,S)
  __floordiv__ : (S,S) -> S
  __mod__      : (S,S) -> S

  __lshift__   : (S,S) -> S
  __rshift__   : (S,S) -> S

  __invert__   : (S) -> S


class Integral$opaque ():       # Exists S:
  proto       : Integral[S]
  impl        : S


## Extensions ######################################################################################

class Collection$list (Collection[list[A],A]):
    w$Sequence$list : Sequence$list[A]
    def __init__($wself, w$Sequence$list):
        Collection.__init__($wself)
        $wself.w$Sequence$list = w$Sequence$list
class Plus$list (Plus[list[A],A]):
    w$Sequence$list : Sequence$list[A]
    def __init__($wself, w$Sequence$list):
        Plus.__init__($wself)
        $wself.w$Sequence$list = w$Sequence$list
class Sequence$list[A] (Sequence[list[A],A]):
    def __init__($wself):
        Sequence.__init__(Collection$list($wself), Plus$list($wself))

class Container$list[A(Eq)] (Container[A]):
    w$Sequence$list : Sequence[list[A],A]
    def __init__($wself, w$Eq$A : Eq[A]):
        Container.__init__($wself, w$Eq$A)
        $wself.w$Sequence$list = Sequence$list()

class Indexed$dict (Indexed[dict[A,B],A,B]):
    w$Mapping$dict : Mapping$dict[A,B]
    def __init__($wself, w$Eq$A : Eq[A], w$Mapping$dict : Mapping$dict[A,B]):
        Indexed.__init__($wself, w$Eq$A)
        $wself.w$Mapping_dict = w$Mapping$dict
class Mapping$dict[A,B] (Mapping[dict[A,B],A,B]):
    w$Hashable$A : Hashable[A]
    def __init__($wself, w$Hashable$A : Hashable[A]):
        Mapping.__init__($wself, Indexed$dict($wself,w$Hashable$A))
        $wself.w$Hashable$A = w$Hashable$A

class Ord$set (Ord[set[A]]):
    w$Set$set : Set$set[A]
    def __init__($wself, w$Set$set):
        Ord.__init__($wself)
        $wself.w$Set$set = w$Set$set
class Locical$set (Logical[set[A]]):
    w$Set$set : Set$set[A]
    def __init__($wself, w$Set$set):
        Logical.__init__($wself)
        $wself.w$Set$set = w$Set$set
class Minus$set (Minus[set[A]]):
    w$Set$set : Set$set[A]
    def __init__($wself, w$Set$set):
        Minus.__init__($wself)
        $wself.w$Set$set = w$Set$set
class Set$set[A] (Set[set[A],A]):
    w$Hashable$A : Hashable[A]
    def __init__($wself, w$Hashable$A : Hashable[A]):
        Set.__init__($wself, w$Hashable$A, Ord$set($wself), Logical$set($wself), Minus$set($wself))
        $wself.w$Hashable$A = w$Hashable$A

class Iterable$Iterator[A] (Iterable[Iterator[A],A]):
    def __init__($wself):
        Iterable.__init__($wself)

class Ord$str (Ord[str]):
    def __init__($wself):
        Ord.__init__($wself)

class Container$str (Container[str,str]):
    def __init__($wself):
        Container.__init__($wself, Eq$str())

class Sliceable$str (Sliceable[str,str]):
    def __init__($wself):
        Sliceable.__init__($wself)

class Plus$str (Plus[str]):
    def __init__($wself):
        Plus.__init__($wself)

class Hashable$str (Hashable[str]):
    def __init__($wself):
        Hashable.__init__($wself)

class Logical$int (Logical[int]):
    w$Integral$int : Integral$int
    def __init__($wself, w$Integral$int):
        $wself.w$Integral$int = w$Integral$int
class Plus$int (Plus[int]):
    w$Integral$int : Integral$int
    def __init__($wself, w$Integral$int):
        $wself.w$Integral$int = w$Integral$int
class Minus$int (Minus[int]):
    w$Integral$int : Integral$int
    def __init__($wself, w$Integral$int):
        $wself.w$Integral$int = w$Integral$int
class Complex$int (Complex[int]):
    w$Integral$int : Integral$int
    def __init__($wself, w$Integral$int):
        Complex.__init__($wself, Plus$int($wself), Minus$int($wself))
        $wself.w$Integral$int = w$Integral$int
class Integral$int (Integral[int]):
    def __init__($wself):
        Integral.__init__($wself, Complex$int($wself), Logical$int($wself))

class Hashable$int (Hashable[int]):
    def __init__($wself):
        Hashable.__init__($wself)

class Plus$float (Plus[float]):
    w$Real$float : Real$float
    def __init__($wself, w$Real$float):
        $wself.w$Real$float = w$Real$float
class Minus$float (Minus[float]):
    w$Real$float : Real$float
    def __init__($wself, w$Real$float):
        $wself.w$Real$float = w$Real$float
class Complex$float (Complex[float]):
    w$Real$float : Real$float
    def __init__($wself, w$Real$float):
        Complex.__init__($wself, Plus$float($wself), Minus$float($wself))
        $wself.w$Real$float = w$Real$float
class Real$float (Real[float]):
    def __init__($wself):
        Real.__init__($wself, Complex$float($wself))

class Hashable$float (Hashable[float]):
    def __init__($wself):
        Hashable.__init__($wself)

## Builtin functions #####################################################

def abs(x : Complex$opaque) -> Real$opaque:
    return x.$proto.__abs__(x.$impl)
    
x0 : (x: int, y: int)                                    # struct
x1 : (x: int, y: A, **B)                                 # open struct; two fileds of the same type
x2 : (int  | float)                                      # union
x3 : ('str1' | 'str2' | int)                             # union with string literals
x4 : (int,bool)                                          # tuple
x5 : ?B12                                                # option type; type var
x6 : Set[int]                                            # Class with type argument
x7 : [A(Hashable), B, S(Mapping[A,B])] => (S)->dict[A,B] # Qualified/constrained type
x8 : ((int) -> int,(b : bool),(int,int))                 # more complicated tuple
x9 : sync X (int,*A,b : bool,**B) -> SomeClass[int]      # function with effects and all kinds of parameters

a0 : (float,float) -> (float | 'division by zero')       # function without effects; union result
a1 : (str,*,c : bool) -> None                            # function with * separation of pos and kwd parameters
a2 : (int) -> (int) -> int                               # higher order function
a3 : {int}                                               # set of ints (protocol)
a4 : [(float,bool)]                                      # list of tuples (protocol)
a5 : {{[int]}}                                           # more complicated set (protcol)
a6 : {[int]:(int) -> bool}                               # a dict (protocol)
a7 : (set[int],list[float],dict[{int},bool])             # tuple of mutable data structures

y1 : (x: float, y: A, **)                                # open struct
y2 : (**)                                                # open struct
y3 : (**A)                                               # open struct
y4 : (int, bool, *A)                                     # open tuple
y5 : (int, bool, *)                                      # open tuple
y6 : (*)                                                 # open tuple
y7 : (*A)                                                # open tuple
y8 : ()                                                  # empty tuple (should count as empty struct as well?)

f0 : () -> int
f1 : (int) -> bool
f2 : (int,) -> int
f3 : (int,bool) -> int
f4 : (int,bool,) -> int
f5 : (int,bool,*) -> int
f6 : (int,bool,*,) -> int
f7 : (int,bool,*A) -> int
f8 : (int,bool,*A,) -> int
f9 : (*) -> int
f10 : (*,) -> int
f11 : (*A) -> int
f12 : (*A,) -> int

f13 : (x : float) -> int
f14 : (x : float,) -> int
f15 : (x : float, y : str) -> int
f16 : (x : float, y : str, **) -> int
f17 : (x : float, y : str, **A) -> int
f18 : (x : float, y : str,**,) -> int
f19 : (x : float, y : str,**A,) -> int

f20 : (int, x : float) -> int
f21 : (int, *A,x:float, **B,) -> int
f22 : (,) -> int                                        # Should this really be allowed??

f23 : [A] => (Self, y:Self) -> [A]                      # functiona with Self and [A] disambiguation!

z0 : (int,bool,*A,)
z1 : (x : float)
z2 : (x : (y : float,z : bool),**A,)
z3 : [A]                                                # sequence that also could be the start of a qualified type


def elem [A(Eq), B(Boolean)] (x:A, xs:[A]) -> B:        # function with explicit quant/qualifiers
    pass

def fails_incorrectly(a, *b, c):
    pass

protocol Apa():
    def __init__(self):
        pass
        
    @classattr
    x : int
    
    @staticmethod
    def __eq__(x:Self, y:Self) -> bool:
        pass
    
    # @classmethod
    def f(x):
        pass


actor Test [T](v0:T):
    def m(x):
        pass


def f(z):
    pass

extension Mapping[A,B(Eq)] (Eq):
    pass

extension __builtin__.int (Eq):
    pass

protocol Indexed[A,B]:                                   # just a protocol
    __getitem__ : (A) -> B

g : ([A]=>(A)->A, int, str) -> (int,str)                 # a rank-2 scheme with positional arguments

h : (f:[A]=>(A)->A, x:int, y:@dict[int,str]) -> str      # a rank-2 scheme with keyword arguments and an @ type


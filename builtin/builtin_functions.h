#pragma once
#include "function.h"

// print /////////////////////////////////////////////////////////////////

void $print(int size, ...);

// enumerate ////////////////////////////////////////////////////////////

struct B_IteratorD_enumerate;
typedef struct B_IteratorD_enumerate *B_IteratorD_enumerate;

struct B_IteratorD_enumerateG_class {
  char *$GCINFO;
  int $class_id;
  $SuperG_class $superclass;
  void (*__init__)(B_IteratorD_enumerate, B_Iterator,B_int);
  void (*__serialize__)(B_IteratorD_enumerate,$NoneType);
  B_IteratorD_enumerate (*__deserialize__)(B_IteratorD_enumerate,$NoneType);
  B_bool (*__bool__)(B_IteratorD_enumerate);
  B_str (*__str__)(B_IteratorD_enumerate);
  B_str (*__repr__)(B_IteratorD_enumerate);
  $WORD(*__next__)(B_IteratorD_enumerate);
};

struct B_IteratorD_enumerate {
  struct B_IteratorD_enumerateG_class *$class;
  B_Iterator it;
  int nxt;
};

extern struct B_IteratorD_enumerateG_class B_IteratorD_enumerateG_methods;
B_IteratorD_enumerate B_IteratorD_enumerateG_new(B_Iterator,B_int);

B_Iterator $enumerate(B_Iterable wit, $WORD iter, B_int start);

// filter ////////////////////////////////////////////////////////////

struct B_IteratorD_filter;
typedef struct B_IteratorD_filter *B_IteratorD_filter;

struct B_IteratorD_filterG_class {
  char *$GCINFO;
  int $class_id;
  $SuperG_class $superclass;
  void (*__init__)(B_IteratorD_filter, B_Iterator, $pure);
  void (*__serialize__)(B_IteratorD_filter,$NoneType);
  B_IteratorD_filter (*__deserialize__)(B_IteratorD_filter,$NoneType);
  B_bool (*__bool__)(B_IteratorD_filter);
  B_str (*__str__)(B_IteratorD_filter);
  B_str (*__repr__)(B_IteratorD_filter);
  $WORD(*__next__)(B_IteratorD_filter);
};

struct B_IteratorD_filter {
  struct B_IteratorD_filterG_class *$class;
  B_Iterator it;
  $pure f;
};

extern struct B_IteratorD_filterG_class B_IteratorD_filterG_methods;
B_IteratorD_filter B_IteratorD_filterG_new(B_Iterator, $pure);

B_Iterator $filter(B_Iterable wit, $pure, $WORD iter);

// map ////////////////////////////////////////////////////////////

struct B_IteratorD_map;
typedef struct B_IteratorD_map *B_IteratorD_map;

struct B_IteratorD_mapG_class {
  char *$GCINFO;
  int $class_id;
  $SuperG_class $superclass;
  void (*__init__)(B_IteratorD_map, B_Iterator, $pure);
  void (*__serialize__)(B_IteratorD_map,$NoneType);
  B_IteratorD_map (*__deserialize__)(B_IteratorD_map,$NoneType);
  B_bool (*__bool__)(B_IteratorD_map);
  B_str (*__str__)(B_IteratorD_map);
  B_str (*__repr__)(B_IteratorD_map);
  $WORD(*__next__)(B_IteratorD_map);
};

struct B_IteratorD_map {
  struct B_IteratorD_mapG_class *$class;
  B_Iterator it;
  $pure f;
};

extern struct B_IteratorD_mapG_class B_IteratorD_mapG_methods;
B_IteratorD_map B_IteratorD_mapG_new(B_Iterator, $pure);

B_Iterator $map(B_Iterable wit, $pure, $WORD iter);


// zip ////////////////////////////////////////////////////////////

struct B_IteratorD_zip;
typedef struct B_IteratorD_zip *B_IteratorD_zip;

struct B_IteratorD_zipG_class {
  char *$GCINFO;
  int $class_id;
  $SuperG_class $superclass;
  void (*__init__)(B_IteratorD_zip, B_Iterator, B_Iterator);
  void (*__serialize__)(B_IteratorD_zip,$NoneType);
  B_IteratorD_zip (*__deserialize__)(B_IteratorD_zip,$NoneType);
  B_bool (*__bool__)(B_IteratorD_zip);
  B_str (*__str__)(B_IteratorD_zip);
  B_str (*__repr__)(B_IteratorD_zip);
  $WORD(*__next__)(B_IteratorD_zip);
};

struct B_IteratorD_zip {
  struct B_IteratorD_zipG_class *$class;
  B_Iterator it1;
  B_Iterator it2;
};

extern struct B_IteratorD_zipG_class B_IteratorD_zipG_methods;
B_IteratorD_zip B_IteratorD_zipG_new(B_Iterator, B_Iterator);

B_Iterator $zip(B_Iterable wit1, B_Iterable wit2, $WORD iter1, $WORD iter2);


// EqOpt //////////////////////////////////////////////////////

struct B_EqOpt;
typedef struct B_EqOpt *B_EqOpt;

struct B_EqOptG_class {
    char *$GCINFO;
    int $class_id;
    $SuperG_class $superclass;
    void (*__init__)(B_EqOpt, B_Eq);
    B_bool (*__eq__)(B_EqOpt, $WORD, $WORD);
    B_bool (*__ne__)(B_EqOpt, $WORD, $WORD);
};

struct B_EqOpt {
    struct B_EqOptG_class *$class;
    B_Eq W_Eq$A;
};

B_EqOpt B_EqOptG_new(B_Eq);


// Various small functions //////////////////////////////////////////////////////////

$WORD $min(B_Ord wit, B_Iterable wit2, $WORD iter, $WORD deflt);
$WORD $max(B_Ord wit, B_Iterable wit2, $WORD iter, $WORD deflt);

// Signatures generated by actonc 

$WORD $abs (B_Number, B_Real, $WORD);
B_bool $all (B_Iterable, $WORD);
B_bool $any (B_Iterable, $WORD);
B_tuple $divmod (B_Integral, $WORD, $WORD);
B_int $hash (B_Hashable, $WORD);
B_Iterator $iter (B_Iterable, $WORD);
B_int $len (B_Collection, $WORD);
$WORD $next (B_Iterator);
$WORD $pow (B_Number, $WORD, $WORD);
B_str $repr(B_value);
B_Iterator $reversed (B_Sequence, $WORD);
$WORD $round (B_Real, $WORD, B_int);
$WORD $sum($Plus, B_Iterable, $WORD, $WORD);
